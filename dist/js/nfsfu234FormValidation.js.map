{"version":3,"sources":["../../src/ts/nfsfu234FormValidation.ts","../../src/ts/errorHandling/ExceptionHandler.ts","../../src/ts/utilities/index.ts","../../src/ts/utilities/getPageUrl.ts","../../src/ts/ajax/ajax.ts","../../src/ts/utilities/focusInputElement.ts","../../src/ts/errorHandling/displayErrorInline.ts","../../src/ts/errorHandling/displayErrorModal.ts","../../src/ts/errorHandling/displayError.ts","../../src/ts/formValidations/getFormDetails.ts","../../src/ts/utilities/countString.ts","../../src/ts/formValidations/restrictInputLengthWithCounter.ts","../../src/ts/utilities/containsOnlyIntegers.ts","../../src/ts/utilities/isDate.ts","../../src/ts/utilities/isEmail.ts","../../src/ts/utilities/isURL.ts","../../src/ts/utilities/isZIP.ts","../../src/ts/formValidations/validateCheckbox.ts","../../src/ts/formValidations/validateRadio.ts","../../src/ts/formValidations/validateInput.ts","../../src/ts/formValidations/validateAllnput.ts","../../src/ts/formValidations/validateSelect.ts","../../src/ts/formValidations/validateAllSelect.ts","../../src/ts/formValidations/validateTextarea.ts","../../src/ts/formValidations/validateAllTextarea.ts","../../src/ts/formValidations/validate.ts","../../src/ts/formValidations/validateAllCheckbox.ts","../../src/ts/formValidations/validateAllRadio.ts","../../src/ts/password-handling/checkPassword.ts","../../src/ts/password-handling/hashPassword.ts","../../src/ts/password-handling/generatePassword.ts","../../src/ts/password-handling/verifyPassword.ts","../../src/ts/utilities/checkVariableType.ts","../../src/ts/utilities/isOnline.ts","../../src/ts/utilities/loading.ts","../../src/ts/utilities/redirect.ts","../../src/ts/utilities/reset.ts","../../src/ts/utilities/togglePasswordVisibility.ts","../../src/ts/utilities/togglePasswordVisibilityAll.ts"],"names":["nfsfu234FormValidation_exports","__export","nfsfu234FormValidation_default","__toCommonJS","LogLevelInterface","ExceptionHandler","error","level","areAllElementsTrue","arr","element","checkVariableType","variable","getPageUrl","getPageUrl_default","makeAjaxRequest","url","options","individualResponseMessage","response","responseData","prepareAjaxOptions","AJAXOptions","method","headers","ignoreBodyMessage","type","body","ajax","ajax_default","focusInputElement","inputElement","duration","focusInputElement_default","displayErrorInline","inputField","message","isSuccess","errorMessageContainer","parentNode","displayErrorInline_default","displayErrorModal","form","errorContainerId","shouldLogToConsole","errorMessageParentContainer","errorMessageMessageContainer","errorMessageIconContainer","errorMessageContainerCloseBtn","displayErrorModal_default","displayError","details","success","displayError_default","getFormDetails","u_form","requestData","shouldContinue","input","index","attributeName","inputValue","textarea","textareaValue","select","selectValue","getFormDetails_default","countString","str","countString_default","restrictInputLengthWithCounter","counterContainer","maxLength","minLength","shouldButtonDisable","textLength","returnMessage","counterElement","button","restrictInputLengthWithCounter_default","containsOnlyIntegers","containsOnlyIntegers_default","formats","isDate","value","format","regex","isDate_default","isEmail","isEmail_default","isURL","isURL_default","isZIP","zipCode","isZIP_default","validateCheckbox","checkboxInputField","callback","customErrorMessage","errorType","includeHTML","isRequired","errorMessage","validateCheckbox_default","validateRadio","radioInputField","radioName","radioGroup","isAnyRadioChecked","radioInput","radio","validateRadio_default","validateInput","customErrorMessages","inputType","validateRadioResponse","validateInput_default","validateAllInput","failureReturnMessage","allInputsInForm","validateInputResponse","proccessedResponse","validateAllnput_default","validateSelect","selectField","isErrorInline","validateSelect_default","validateAllSelect","allSelectsInForm","validateSelectResponse","validateAllSelect_default","validateTextarea","textareaField","validateTextarea_default","validateAllTextarea","allTextareasInForm","validateAllTextareaResponse","validateAllTextarea_default","validateForm","errMsg","errMsgArray","isValidateAllInputs","isValidateAllTextareas","isValidateAllSelects","msg","resMsg","validate_default","validateAllCheckbox","allCheckboxesInForm","checkbox","validateAllCheckbox_default","validateAllRadio","allRadiosInForm","validateAllRadio_default","checkPassword","password","includeSymbolsCheck","userSymbolRegex","uppercaseRegex","lowercaseRegex","numbersRegex","checkPassword_default","bcrypt","hashPassword","salt","hashPassword_default","generatePassword","length","shouldHash","uppercaseLetters","lowercaseLetters","numbers","symbols","charactersAdded","randomCharType","hashedPassword","generatePassword_default","verifyPassword","stringPassword","isHashed","verifyPassword_default","checkVariableType_default","isOnline","isOnline_default","loading","submitBtn","btn","formElement","loading_default","redirect","delay","redirect_default","reset","targetForm","reset_default","togglePasswordVisibility","showIcon","hideIcon","allTogglePasswordsButton","updateIcon","iconContainer","toggleBtn","togglePasswordVisibility_default","togglePasswordVisibilityAll","icons","uform","toggleAll","allPasswordInputs","togglePasswordVisibilityAll_default","NFSFU234FormValidation","formDetails","e","isAjax","ajaxOptions","requestMethod","requestHeaders","i","attr","originalName","match","headerKey","userOptions","processedIsAjax","processedAjaxOptions","errMsgFromFunction","errMessageFromValidate","responseCode","errorDetails","resolve","email","number","string","validateResponse","errorLogLevel","reject"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nimport ajax from \"./ajax/ajax\";\r\nimport ErrorHandler from \"./errorHandling\";\r\nimport { ExceptionHandler, LogLevelInterface } from \"./errorHandling/ExceptionHandler\";\r\nimport displayError from \"./errorHandling/displayError\";\r\nimport submitForm from \"./formSubmission/submitHandler\";\r\nimport getFormDetails from \"./formValidations/getFormDetails\";\r\nimport restrictInputLengthWithCounter from \"./formValidations/restrictInputLengthWithCounter\";\r\nimport validateForm from \"./formValidations/validate\";\r\nimport validateAllCheckbox from \"./formValidations/validateAllCheckbox\";\r\nimport validateAllRadio from \"./formValidations/validateAllRadio\";\r\nimport validateAllSelect from \"./formValidations/validateAllSelect\";\r\nimport validateAllTextarea from \"./formValidations/validateAllTextarea\";\r\nimport validateAllInput from \"./formValidations/validateAllnput\";\r\nimport validateCheckbox from \"./formValidations/validateCheckbox\";\r\nimport validateInput from \"./formValidations/validateInput\";\r\nimport validateRadio from \"./formValidations/validateRadio\";\r\nimport validateSelect from \"./formValidations/validateSelect\";\r\nimport validateTextarea from \"./formValidations/validateTextarea\";\r\nimport ErrorMessageInterface from \"./interfaces/ErrorMessagesInterface\";\r\nimport checkPassword from \"./password-handling/checkPassword\";\r\nimport generatePassword from \"./password-handling/generatePassword\";\r\nimport hashPassword from \"./password-handling/hashPassword\";\r\nimport verifyPassword from \"./password-handling/verifyPassword\";\r\nimport checkVariableType from \"./utilities/checkVariableType\";\r\nimport checkType from \"./utilities/checkVariableType\";\r\nimport containsOnlyIntegers from \"./utilities/containsOnlyIntegers\";\r\nimport countString from \"./utilities/countString\";\r\nimport getPageUrl from \"./utilities/getPageUrl\";\r\nimport isEmail from \"./utilities/isEmail\";\r\nimport isOnline from \"./utilities/isOnline\";\r\nimport isURL from \"./utilities/isURL\";\r\nimport isZIP from \"./utilities/isZIP\";\r\nimport loading from \"./utilities/loading\";\r\nimport redirect from \"./utilities/redirect\";\r\nimport reset from \"./utilities/reset\";\r\nimport togglePasswordVisibility from \"./utilities/togglePasswordVisibility\";\r\nimport togglePasswordVisibilityAll from \"./utilities/togglePasswordVisibilityAll\";\r\n\r\n\r\n// src/interfaces/FormValidationOptions.ts\r\n\r\n    \r\nclass NFSFU234FormValidation {\r\n    // private attributes\r\n    private AJAXResult: null | Promise<any>;\r\n\r\n    // public attributes\r\n    public form: HTMLFormElement | HTMLDivElement | undefined;\r\n    \r\n    public customErrorMessages: { [key: string]: string } = {};\r\n\r\n    constructor(formDetails?: any, AJAXOptions?: any) {\r\n        console.log(\"NFSFU234FormValidation is loaded....\");\r\n    \r\n        if (typeof window === 'undefined') {\r\n            this.form = undefined;\r\n        } else {\r\n            // Initial assignment of this.form\r\n            let formElement: HTMLFormElement | HTMLDivElement | undefined = undefined;\r\n    \r\n            // Check if formDetails is provided and valid\r\n            if (formDetails && formDetails['form']) {\r\n                if (typeof formDetails['form'] === 'string' && formDetails['form'] !== '') {\r\n                    formElement = document.getElementById(formDetails['form']) as HTMLFormElement | HTMLDivElement | undefined;\r\n                } else if (formDetails['form'] instanceof HTMLElement) {\r\n                    formElement = formDetails['form'] as HTMLFormElement | HTMLDivElement;\r\n                }\r\n            }\r\n    \r\n            // Fallback to default form selectors if formElement is not set\r\n            if (!formElement) {\r\n                formElement = document.getElementById('jsForm') as HTMLFormElement | HTMLDivElement | undefined;\r\n            }\r\n            if (!formElement) {\r\n                formElement = document.querySelector('form') as HTMLFormElement | HTMLDivElement | undefined;\r\n            }\r\n    \r\n            // Assign formElement to this.form\r\n            this.form = formElement;\r\n        }\r\n    \r\n        // If form is found and is an HTMLElement, add novalidate attribute and submit event listener\r\n        if (this.form && this.form instanceof HTMLElement) {\r\n            if (!this.form.hasAttribute('novalidate')) {\r\n                this.form.setAttribute('novalidate', '');\r\n            }\r\n    \r\n            this.form.addEventListener('submit', (e) => {\r\n                e.preventDefault();\r\n            });\r\n        }\r\n    \r\n        this.AJAXResult = null; // Store the result of an AJAX call.\r\n    }\r\n    \r\n\r\n    private populateOptionsVariables(options: any, formElement: HTMLFormElement | HTMLDivElement | undefined) {\r\n        let isAjax = false;\r\n        let ajaxOptions: null | {\r\n            url: string,\r\n            RequestMethod: \"GET\" | \"POST\" | \"PATCH\" | \"UPDATE\" | \"DELETE\",\r\n            RequestHeader?: { [key: string]: string },\r\n            RequestBody?: object | FormData | JSON\r\n        } = null;\r\n\r\n        if (typeof options === 'object' && options !== null) {\r\n            isAjax = options.isAjax === true || false;\r\n            ajaxOptions = options.ajaxOptions || null;\r\n        } else if (formElement) {\r\n            isAjax = formElement.getAttribute('isAjax')?.trim() === \"true\" || false;\r\n\r\n            const url = formElement.getAttribute('action') || '';\r\n            const requestMethod = (formElement.getAttribute('method') || 'GET').toUpperCase();\r\n\r\n            const requestHeaders: { [key: string]: string } = {};\r\n            const regex = /^nfsfu234_fv_reqheader_(.+)$/i;\r\n\r\n            for (let i = 0; i < formElement.attributes.length; i++) {\r\n                const attr = formElement.attributes[i];\r\n                const originalName = attr.name;\r\n                const attrName = attr.name.toLowerCase();\r\n                const match = attrName.match(regex);\r\n\r\n                if (match) {\r\n                    const headerKey = match[1];\r\n                    requestHeaders[headerKey] = attr.value;\r\n                }\r\n            }\r\n\r\n            ajaxOptions = {\r\n                url,\r\n                RequestMethod: requestMethod as \"GET\" | \"POST\" | \"PATCH\" | \"UPDATE\" | \"DELETE\",\r\n                RequestHeader: Object.keys(requestHeaders).length > 0 ? requestHeaders : undefined,\r\n                RequestBody: undefined\r\n            };\r\n        }\r\n\r\n        return { isAjax, ajaxOptions };\r\n    }\r\n\r\n    // public submit(userOptions?: HTMLFormElement | HTMLDivElement | string | { form: string | HTMLFormElement | HTMLDivElement, customErrorMessages?: { [key: string]: string } }, callback?: any): boolean | Promise<any> {\r\n    //     this.form = this.form || undefined;\r\n    //     this.customErrorMessages = this.customErrorMessages || {};\r\n\r\n    //     let formElement: HTMLFormElement | HTMLDivElement | undefined = this.form;\r\n    //     let options: any = this.customErrorMessages;\r\n\r\n    //     let isAjax = false;\r\n    //     let ajaxOptions: null | {\r\n    //         url: string,\r\n    //         RequestMethod: \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"UPDATE\" | \"DELETE\",\r\n    //         RequestHeader?: object,\r\n    //         RequestBody?: object | FormData | JSON | any\r\n    //     } = null;\r\n\r\n    //     if (typeof userOptions === 'string') {\r\n    //         formElement = document.getElementById(userOptions) as HTMLFormElement | HTMLDivElement | undefined;\r\n    //         options.form = formElement;\r\n    //         options.customErrorMessages = [];\r\n    //     } else if (userOptions instanceof HTMLFormElement || userOptions instanceof HTMLDivElement) {\r\n    //         formElement = userOptions;\r\n    //         options.form = userOptions;\r\n    //         options.customErrorMessages = [];\r\n    //     } else if (userOptions && typeof userOptions === 'object' && 'form' in userOptions) {\r\n    //         if (typeof userOptions.form === 'string') {\r\n    //             formElement = document.getElementById(userOptions.form) as HTMLFormElement | HTMLDivElement | undefined;\r\n    //         } else if (userOptions.form instanceof HTMLFormElement || userOptions.form instanceof HTMLDivElement) {\r\n    //             formElement = userOptions.form;\r\n    //         }\r\n    //         options.form = formElement;\r\n    //         options.customErrorMessages = userOptions.customErrorMessages ?? [];\r\n    //     } else {\r\n    //         formElement = this.form;\r\n    //         options.form = this.form;\r\n    //         options.customErrorMessages = [];\r\n    //     }\r\n\r\n    //     if (formElement) {\r\n    //         const doesNoValidateAttrExist = formElement.getAttribute('novalidate') ? true : false;\r\n\r\n    //         if (!doesNoValidateAttrExist) {\r\n    //             formElement.setAttribute('novalidate', '');\r\n    //         }\r\n\r\n    //         formElement.addEventListener('submit', (e) => {\r\n    //             e.preventDefault();\r\n    //         });\r\n\r\n    //         const { isAjax: processedIsAjax, ajaxOptions: processedAjaxOptions } = this.populateOptionsVariables(userOptions, formElement);\r\n\r\n    //         let errMsg: ErrorMessageInterface = { message: \"\", type: \"\" };\r\n    //         const errMsgFromFunction = validateForm(formElement, options);\r\n\r\n    //         if (errMsgFromFunction === true) {\r\n    //             errMsg.message = \"success\";\r\n    //             errMsg.type = \"success\";\r\n    //             errMsg.data = null;\r\n    //         } else if (typeof errMsgFromFunction === 'object') {\r\n    //             const errMessageFromValidate = errMsgFromFunction.message || null;\r\n    //             errMsg.message = errMessageFromValidate || \"Error\";\r\n    //             errMsg.data = errMsgFromFunction;\r\n    //         } else {\r\n    //             errMsg.message = \"Error\";\r\n    //             errMsg.type = \"error\";\r\n    //         }\r\n\r\n    //         isAjax = processedIsAjax;\r\n    //         ajaxOptions = processedAjaxOptions;\r\n\r\n    //         if (!ajaxOptions) {\r\n    //             return false;\r\n    //         }\r\n\r\n    //         ajaxOptions.RequestBody = getFormDetails(formElement);\r\n\r\n    //         if (errMsg.message === \"success\") {\r\n    //             if (isAjax && ajaxOptions !== null) {\r\n    //                 return ajax(ajaxOptions).then(response => {\r\n    //                     const responseCode = response.code || response.status;\r\n    //                     if (responseCode >= 300 && responseCode <= 500) {\r\n    //                         const errorDetails = {\r\n    //                             type: 'modal',\r\n    //                             message: response.message,\r\n    //                             duration: 3000,\r\n    //                             element: formElement,\r\n    //                             success: false,\r\n    //                         };\r\n\r\n    //                         errMsg.message = response.message;\r\n    //                         errMsg.type = \"error\";\r\n    //                         errMsg.code = responseCode;\r\n    //                         errMsg.data = response.data;\r\n\r\n    //                         this.displayError(errorDetails);\r\n    //                         console.error(\"THIS IS ERR_ \", response.message);\r\n\r\n    //                         return errMsg;\r\n    //                     } else {\r\n    //                         console.log(\"Success\");\r\n    //                         return response;\r\n    //                     }\r\n    //                 }).catch(error => {\r\n    //                     console.error(\"LOLK \", error);\r\n    //                     return errMsg;\r\n    //                 });\r\n    //             }\r\n    //         }\r\n\r\n    //         if (typeof callback === 'function') {\r\n    //             const message = callback(errMsg);\r\n    //             return true;\r\n    //         }\r\n\r\n    //         return new Promise((resolve) => {\r\n    //             resolve(errMsg);\r\n    //         });\r\n    //     } else {\r\n    //         ExceptionHandler('Form element not found.');\r\n    //         return false;\r\n    //     }\r\n    // }\r\n\r\n    public submit(\r\n        userOptions?: HTMLFormElement | HTMLDivElement | string | { form: string | HTMLFormElement | HTMLDivElement, customErrorMessages?: { [key: string]: string } }, \r\n        callback?: any\r\n    ): boolean | Promise<any> {\r\n        this.form = this.form || undefined;\r\n        this.customErrorMessages = this.customErrorMessages || {};\r\n    \r\n        let formElement: HTMLFormElement | HTMLDivElement | undefined = this.form;\r\n        let options: any = this.customErrorMessages;\r\n    \r\n        let isAjax = false;\r\n        let ajaxOptions: null | {\r\n            url: string,\r\n            RequestMethod: \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"UPDATE\" | \"DELETE\",\r\n            RequestHeader?: object,\r\n            RequestBody?: object | FormData | JSON | any\r\n        } = null;\r\n    \r\n        // Handle userOptions to determine formElement and options\r\n        if (typeof userOptions === 'string') {\r\n            formElement = document.getElementById(userOptions) as HTMLFormElement | HTMLDivElement | undefined;\r\n            options = { form: formElement, customErrorMessages: [] };\r\n        } else if (userOptions instanceof HTMLFormElement || userOptions instanceof HTMLDivElement) {\r\n            formElement = userOptions;\r\n            options = { form: formElement, customErrorMessages: [] };\r\n        } else if (userOptions && typeof userOptions === 'object' && 'form' in userOptions) {\r\n            if (typeof userOptions.form === 'string') {\r\n                formElement = document.getElementById(userOptions.form) as HTMLFormElement | HTMLDivElement | undefined;\r\n            } else if (userOptions.form instanceof HTMLFormElement || HTMLDivElement) {\r\n                formElement = userOptions.form;\r\n            }\r\n            options = { form: formElement, customErrorMessages: userOptions.customErrorMessages ?? [] };\r\n        }\r\n    \r\n        // Ensure formElement is available\r\n        if (!formElement) {\r\n            ExceptionHandler('Form element not found.');\r\n            return false;\r\n        }\r\n    \r\n        // Handle form's novalidate attribute\r\n        const doesNoValidateAttrExist = formElement.getAttribute('novalidate') !== null;\r\n        if (!doesNoValidateAttrExist) {\r\n            formElement.setAttribute('novalidate', '');\r\n        }\r\n    \r\n        // Prevent default form submission\r\n        formElement.addEventListener('submit', (e) => {\r\n            e.preventDefault();\r\n        });\r\n    \r\n        // Process options for Ajax submission\r\n        const { isAjax: processedIsAjax, ajaxOptions: processedAjaxOptions } = this.populateOptionsVariables(userOptions, formElement);\r\n        isAjax = processedIsAjax;\r\n        ajaxOptions = processedAjaxOptions;\r\n    \r\n        // Validate form and determine the error message\r\n        let errMsg: ErrorMessageInterface = { message: \"\", type: \"\" };\r\n        const errMsgFromFunction = validateForm(formElement, options);\r\n    \r\n        if (errMsgFromFunction === true) {\r\n            errMsg.message = \"success\";\r\n            errMsg.type = \"success\";\r\n            errMsg.data = null;\r\n        } else if (typeof errMsgFromFunction === 'object' && errMsgFromFunction !== null && 'message' in errMsgFromFunction) {\r\n            const errMessageFromValidate = errMsgFromFunction.message;\r\n            errMsg.message = (typeof errMessageFromValidate === 'string' || typeof errMessageFromValidate === 'number' || typeof errMessageFromValidate === 'boolean')\r\n                ? errMessageFromValidate \r\n                : \"Error\";\r\n            errMsg.type = \"error\";\r\n            errMsg.data = errMsgFromFunction;\r\n        } else {\r\n            errMsg.message = \"Error\";\r\n            errMsg.type = \"error\";\r\n        }\r\n    \r\n        // Handle Ajax submission if applicable\r\n        if (errMsg.message === \"success\" && isAjax && ajaxOptions !== null) {\r\n            ajaxOptions.RequestBody = getFormDetails(formElement);\r\n            return ajax(ajaxOptions)\r\n                .then(response => {\r\n                    const responseCode = response.code || response.status;\r\n                    if (responseCode >= 300 && responseCode <= 500) {\r\n                        const errorDetails = {\r\n                            type: 'modal',\r\n                            message: response.message,\r\n                            duration: 3000,\r\n                            element: formElement,\r\n                            success: false,\r\n                        };\r\n    \r\n                        errMsg.message = response.message;\r\n                        errMsg.type = \"error\";\r\n                        errMsg.code = responseCode;\r\n                        errMsg.data = response.data;\r\n    \r\n                        this.displayError(errorDetails);\r\n                        console.error(\"THIS IS ERR_ \", response.message);\r\n    \r\n                        return errMsg;\r\n                    } else {\r\n                        console.log(\"Success\");\r\n                        return response;\r\n                    }\r\n                })\r\n                .catch(error => {\r\n                    console.error(\"LOLK \", error);\r\n                    return errMsg;\r\n                });\r\n        }\r\n    \r\n        // Handle callback if provided\r\n        if (typeof callback === 'function') {\r\n            callback(errMsg);\r\n            return true;\r\n        }\r\n    \r\n        // Return a promise resolving to the error message\r\n        return new Promise((resolve) => {\r\n            resolve(errMsg);\r\n        });\r\n    }\r\n    \r\n    \r\n\r\n    // public validate(userOptions?: HTMLFormElement | HTMLDivElement | string | { form: HTMLFormElement | HTMLDivElement | string; customErrorMessages?: any[] }, callback?: any): boolean | Promise<any> {\r\n    //     let formElement: HTMLFormElement | HTMLDivElement | undefined;\r\n    //     let options: any = {}; // Initialize options as an empty object\r\n    \r\n    //     if (typeof userOptions === 'string') {\r\n    //         formElement = document.getElementById(userOptions) as HTMLFormElement | HTMLDivElement | undefined;\r\n    //         options.form = formElement;\r\n    //         options.customErrorMessages = [];\r\n    //     } else if (userOptions instanceof HTMLFormElement || userOptions instanceof HTMLDivElement) {\r\n    //         formElement = userOptions;\r\n    //         options.form = userOptions;\r\n    //         options.customErrorMessages = [];\r\n    //     } else if (userOptions && typeof userOptions === 'object' && 'form' in userOptions) {\r\n    //         if (typeof userOptions.form === 'string') {\r\n    //             formElement = document.getElementById(userOptions.form) as HTMLFormElement | HTMLDivElement | undefined;\r\n    //         } else if (userOptions.form instanceof HTMLFormElement || userOptions.form instanceof HTMLDivElement) {\r\n    //             formElement = userOptions.form;\r\n    //         }\r\n    //         options.form = formElement;\r\n    //         options.customErrorMessages = userOptions.customErrorMessages ?? [];\r\n    //     } else {\r\n    //         formElement = this.form;\r\n    //         options.form = this.form;\r\n    //         options.customErrorMessages = [];\r\n    //     }\r\n    \r\n    //     if (formElement) {\r\n    //         const doesNoValidateAttrExist = formElement.getAttribute('novalidate') ? true : false;\r\n    \r\n    //         if (!doesNoValidateAttrExist) {\r\n    //             formElement.setAttribute('novalidate', '');\r\n    //         }\r\n    \r\n    //         formElement.addEventListener('submit', (e) => {\r\n    //             e.preventDefault();\r\n    //         });\r\n    \r\n    //         // Initialize errMsg with default values\r\n    //         let errMsg: ErrorMessageInterface = { message: \"\", type: \"\" };\r\n    \r\n    //         // Validating the form here\r\n    //         const errMsgFromFunction = validateForm(formElement, options);\r\n    \r\n    //         if (errMsgFromFunction === true) {\r\n    //             errMsg.message = \"success\";\r\n    //             errMsg.type = \"success\";\r\n    //             errMsg.data = null;\r\n    //         } else if (checkVariableType(errMsgFromFunction) === 'object') {\r\n    //             const errMessageFromValidate = errMsgFromFunction.message || null;\r\n    //             errMsg.message = errMessageFromValidate || \"Error\";\r\n    //             errMsg.type = \"error\";\r\n    //             errMsg.data = errMsgFromFunction;\r\n    //         } else {\r\n    //             errMsg.message = \"Error\";\r\n    //             errMsg.type = \"error\";\r\n    //         }\r\n    \r\n    //         if (checkVariableType(callback) === 'function') {\r\n    //             callback(errMsg);\r\n    //             return true;\r\n    //         }\r\n    \r\n    //         return new Promise((resolve, reject) => {\r\n    //             resolve(errMsg);\r\n    //         });\r\n    //     } else {\r\n    //         ExceptionHandler('Form element not found.');\r\n    //         return false;\r\n    //     }\r\n    // }\r\n    \r\n    public validate(\r\n        userOptions?: HTMLFormElement | HTMLDivElement | string | { form: HTMLFormElement | HTMLDivElement | string; customErrorMessages?: any[] }, \r\n        callback?: any\r\n    ): boolean | Promise<any> {\r\n        let formElement: HTMLFormElement | HTMLDivElement | undefined;\r\n        let options: any = {}; // Initialize options as an empty object\r\n    \r\n        // Determine the form element and options based on userOptions\r\n        if (typeof userOptions === 'string') {\r\n            formElement = document.getElementById(userOptions) as HTMLFormElement | HTMLDivElement | undefined;\r\n            options = { form: formElement, customErrorMessages: [] };\r\n        } else if (userOptions instanceof HTMLFormElement || userOptions instanceof HTMLDivElement) {\r\n            formElement = userOptions;\r\n            options = { form: formElement, customErrorMessages: [] };\r\n        } else if (userOptions && typeof userOptions === 'object' && 'form' in userOptions) {\r\n            if (typeof userOptions.form === 'string') {\r\n                formElement = document.getElementById(userOptions.form) as HTMLFormElement | HTMLDivElement | undefined;\r\n            } else if (userOptions.form instanceof HTMLFormElement || userOptions.form instanceof HTMLDivElement) {\r\n                formElement = userOptions.form;\r\n            }\r\n            options = { form: formElement, customErrorMessages: userOptions.customErrorMessages ?? [] };\r\n        } else {\r\n            formElement = this.form;\r\n            options = { form: formElement, customErrorMessages: [] };\r\n        }\r\n    \r\n        // Ensure form element exists\r\n        if (!formElement) {\r\n            ExceptionHandler('Form element not found.');\r\n            return false;\r\n        }\r\n    \r\n        // Handle form's novalidate attribute\r\n        const doesNoValidateAttrExist = formElement.getAttribute('novalidate') !== null;\r\n        if (!doesNoValidateAttrExist) {\r\n            formElement.setAttribute('novalidate', '');\r\n        }\r\n    \r\n        // Prevent default form submission\r\n        formElement.addEventListener('submit', (e) => {\r\n            e.preventDefault();\r\n        });\r\n    \r\n        // Initialize errMsg with default values\r\n        let errMsg: ErrorMessageInterface = { message: \"\", type: \"\" };\r\n    \r\n        // Validate the form using the provided function\r\n        const errMsgFromFunction = validateForm(formElement, options);\r\n    \r\n        if (errMsgFromFunction === true) {\r\n            errMsg.message = \"success\";\r\n            errMsg.type = \"success\";\r\n            errMsg.data = null;\r\n        } else if (typeof errMsgFromFunction === 'object' && errMsgFromFunction !== null && 'message' in errMsgFromFunction) {\r\n            const errMessageFromValidate = errMsgFromFunction.message;\r\n    \r\n            // Ensure the message is of the correct type before assignment\r\n            if (typeof errMessageFromValidate === 'string' || typeof errMessageFromValidate === 'number' || typeof errMessageFromValidate === 'boolean') {\r\n                errMsg.message = errMessageFromValidate;\r\n            } else {\r\n                errMsg.message = \"Error\"; // Fallback to a default message if the type doesn't match\r\n            }\r\n    \r\n            errMsg.type = \"error\";\r\n            errMsg.data = errMsgFromFunction;\r\n        } else {\r\n            errMsg.message = \"Error\";\r\n            errMsg.type = \"error\";\r\n        }\r\n    \r\n        // If a callback is provided, invoke it with errMsg\r\n        if (typeof callback === 'function') {\r\n            callback(errMsg);\r\n            return true;\r\n        }\r\n    \r\n        // Return a promise resolving to the error message\r\n        return new Promise((resolve) => {\r\n            resolve(errMsg);\r\n        });\r\n    }\r\n    \r\n    \r\n    \r\n\r\n\r\n    /**\r\n     * ajax\r\n     */\r\n    public ajax(AJAXOptions: any) {\r\n        \r\n        // return this.AJAXResult = ajax(AJAXOptions);\r\n        return this.AJAXResult = ajax(AJAXOptions);\r\n    }\r\n\r\n    /**\r\n     * getAJAXResponse\r\n     * \r\n     * This function retrieves the AJAX response that was stored in the global variable `AJAXResult`.\r\n     * It returns the AJAX response if available or false if no response is found.\r\n     * \r\n     * @returns {Promise|boolean} - Returns the AJAX response (a Promise) if available; otherwise, returns false.\r\n     */\r\n    getAJAXResponse(): Promise<any> | boolean {\r\n        if (this.AJAXResult) {\r\n            // If `AJAXResult` contains a value (Promise), return the AJAX response\r\n            return this.AJAXResult;\r\n        } else {\r\n            // If `AJAXResult` is empty (null or undefined), return false\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    getFormDetails(form: HTMLFormElement | HTMLDivElement | string)\r\n    {\r\n\r\n        if ( ! form )\r\n        {\r\n            form = this.form as HTMLDivElement;\r\n        }\r\n        \r\n        // console.log(\"hkbik\", getFormDetails(form));\r\n        \r\n\r\n        return getFormDetails(form);\r\n    }\r\n\r\n    loading(message: string, submitBtn: string | HTMLElement | null = null, form: string | HTMLElement | null | undefined = null)\r\n    {\r\n        if (form !== null) {\r\n            form = typeof form === 'string' ? document.getElementById(form) : form;\r\n            form = typeof form === 'undefined' ? this.form : form;\r\n        }\r\n\r\n        // Call the loading function\r\n        return loading(message, submitBtn, form);\r\n    }\r\n\r\n    displayError(details:any)\r\n    {\r\n        displayError(details);\r\n    }\r\n    \r\n    isEmail(email: string): boolean\r\n    {\r\n        return isEmail(email);\r\n    }\r\n\r\n    isURL(url: string)\r\n    {\r\n        return isURL(url);\r\n    }\r\n\r\n    isNumber(number: string | number): boolean\r\n    {\r\n        return checkVariableType(number) === 'number';\r\n    }\r\n\r\n    isZipCode(zipCode: string | number): boolean\r\n    {\r\n        return isZIP(zipCode);\r\n    }\r\n\r\n    isZip(zipCode: string | number): boolean\r\n    {\r\n        return isZIP(zipCode);\r\n    }\r\n\r\n    countString(string: string): number\r\n    {\r\n        return countString(string);\r\n    }\r\n\r\n    async generatePassword(length?:number, shouldHash?: boolean )\r\n    {\r\n        return await generatePassword(length, shouldHash);\r\n    }\r\n\r\n    async generateRandomPassword(length:number, shouldHash:boolean )\r\n    {\r\n        return await generatePassword(length, shouldHash);\r\n    }\r\n\r\n    passwordStrength()\r\n    {}\r\n\r\n    getPasswordStrength()\r\n    {}\r\n\r\n    checkPassword( password: string, minLength: number = 8, maxLength: number = 20, includeSymbolsCheck: boolean = false, userSymbolRegex: RegExp | string = '')\r\n    {\r\n        return checkPassword( password, includeSymbolsCheck, minLength, maxLength, userSymbolRegex );\r\n    }\r\n\r\n    async verifyPassword(stringPassword: string, hashedPassword: string, isHashed: boolean = false): Promise<boolean>\r\n    {\r\n        try {\r\n            // Call verifyPassword and return its result\r\n            return await verifyPassword(stringPassword, hashedPassword, isHashed);\r\n        } catch (error) {\r\n            console.error(\"Error verifying password: \", error); // Log an error if there's an issue\r\n            return false; // Return false in case of an error\r\n        }\r\n    }\r\n\r\n    async passwordMatch(stringPassword: string, hashedPassword: string, isHashed: boolean = false): Promise<boolean>\r\n    {\r\n        try {\r\n            // Call verifyPassword and return its result\r\n            return await verifyPassword(stringPassword, hashedPassword, isHashed);\r\n        } catch (error) {\r\n            console.error(\"Error verifying password: \", error); // Log an error if there's an issue\r\n            return false; // Return false in case of an error\r\n        }\r\n    }\r\n\r\n    async hashPassword(password: string)\r\n    {\r\n        try {\r\n            // Call hashPassword and return its result\r\n            return await hashPassword(password);\r\n        } catch (error) {\r\n            console.error(\"Error hashing password: \", error); // Log an error if there's an issue\r\n            return false; // Return false in case of an error\r\n        }\r\n    }\r\n\r\n    togglePasswordVisibility(input: HTMLInputElement, showIcon: string | HTMLElement | null = null, hideIcon: string | HTMLElement | null = null)\r\n    {\r\n        return togglePasswordVisibility(input, showIcon, hideIcon);\r\n    }\r\n\r\n    togglePasswordVisibilityAll(icons: { \r\n        show: string | HTMLElement | null, \r\n        hide: string | HTMLElement | null \r\n    } , uform: string | HTMLFormElement | HTMLDivElement | null = null, toggleAll: boolean = false)\r\n    {\r\n        return togglePasswordVisibilityAll(icons, uform, toggleAll);\r\n    }\r\n\r\n    validateInput(inputField: HTMLInputElement | string, options: any = {}, callback?: any)\r\n    {\r\n        let individualResponseMessage: ErrorMessageInterface | boolean = {  type: 'error', code : 400 };\r\n\r\n        if ( typeof inputField === 'string' )\r\n        {\r\n            inputField = document.getElementById(inputField) as HTMLInputElement\r\n        }\r\n\r\n        if ( ! inputField  )\r\n        {\r\n            let errorLogLevel = LogLevelInterface;\r\n\r\n            individualResponseMessage.message = \"The Input Feild you are trying to validate is undefined.\";\r\n\r\n            // console.log(individualResponseMessage);\r\n            \r\n            ExceptionHandler(\"The Input Feild you are trying to validate is undefined.\");\r\n\r\n            // return individualResponseMessage;\r\n        }        \r\n\r\n        else\r\n        {\r\n\r\n            options.form = options.form ?? this.form\r\n\r\n            const validateResponse: string | boolean | ErrorMessageInterface  = validateInput(inputField, options, callback);\r\n\r\n            if ( validateResponse === true )\r\n            {\r\n                return true;\r\n            }\r\n\r\n            individualResponseMessage = validateResponse as ErrorMessageInterface\r\n\r\n        }\r\n\r\n        // let errMsg = validateResponse.message;\r\n\r\n        if (checkVariableType(callback) === 'function') {\r\n            const message = callback(individualResponseMessage);\r\n            // return true;\r\n        }\r\n\r\n        return new Promise((resolve, reject)=>{\r\n\r\n            resolve(individualResponseMessage)\r\n\r\n        });\r\n\r\n        // return validateInput(inputField, options, callback);\r\n    }\r\n\r\n    validateAllInput(form: HTMLFormElement | HTMLDivElement | string, customErrorMessages: any)\r\n    {\r\n\r\n        form = form ?? this.form;\r\n        return validateAllInput(form, customErrorMessages);\r\n    }\r\n\r\n    validateRadio(radioInputField: HTMLInputElement | string, customErrorMessage?: any)\r\n    {\r\n        return validateRadio(radioInputField, customErrorMessage);\r\n    }\r\n\r\n    validateAllRadio(form: HTMLFormElement | HTMLDivElement, customErrorMessage: any)\r\n    {\r\n        form = form ?? this.form;\r\n        return validateAllRadio(form, customErrorMessage);\r\n    }\r\n\r\n    validateCheckbox( checkboxInputField: HTMLInputElement, options?: any )\r\n    {\r\n        return validateCheckbox(checkboxInputField, options);\r\n    }\r\n\r\n    validateAllCheckbox(form: HTMLFormElement | HTMLDivElement, options: any)\r\n    {\r\n\r\n        form = form ?? this.form;\r\n\r\n        return validateAllCheckbox(form, options);\r\n    }\r\n\r\n    validateSelect( selectField: HTMLSelectElement, options:any, callback: any)\r\n    {\r\n        options.form = options.form ?? this.form\r\n\r\n        return validateSelect(selectField, options, callback);\r\n    }\r\n\r\n    validateAllSelect(form: HTMLFormElement | HTMLDivElement, options: any)\r\n    {\r\n        return validateAllSelect(form, options);\r\n    }\r\n\r\n    validateTextarea(textareaField: HTMLTextAreaElement, options: any )\r\n    {\r\n        return validateTextarea(textareaField, options);\r\n    }\r\n\r\n    validateAllTextarea(form: HTMLFormElement | HTMLDivElement, options: any)\r\n    {\r\n        return validateAllTextarea(form, options);\r\n    }\r\n\r\n\r\n    restrictInputWithCounter(inputElement: HTMLInputElement | HTMLTextAreaElement, counterContainer: HTMLElement, options: any = {})\r\n    {\r\n        return restrictInputLengthWithCounter(inputElement, counterContainer, options);\r\n    }\r\n\r\n    public containsOnlyIntegers(str: string):boolean\r\n    {\r\n        return containsOnlyIntegers(str)\r\n    }\r\n\r\n    getPageURL()\r\n    {\r\n        return getPageUrl();\r\n    }\r\n\r\n    redirect(url: string | null | false | undefined = null, delay: number = 0)\r\n    {\r\n\r\n        if ( ! url )\r\n        {\r\n            url = this.getPageURL() as string;\r\n        }\r\n\r\n        redirect(url, delay);\r\n    }\r\n\r\n    checkVariableType(variable: any)\r\n    {\r\n        return checkVariableType(variable);\r\n    }\r\n\r\n    isOnline()\r\n    {\r\n        return isOnline();\r\n    }\r\n\r\n    reset(u_form: HTMLFormElement | HTMLDivElement | string): boolean\r\n    {\r\n\r\n        let form;\r\n\r\n        if ( ! u_form )\r\n        {\r\n            form = this.form;\r\n        }\r\n        else\r\n        {\r\n            form = u_form\r\n        }\r\n\r\n        return reset(form);\r\n    }\r\n\r\n    \r\n\r\n}\r\n\r\nif (typeof window !== 'undefined') {\r\n    // Make the library available globally\r\n    (window as any).NFSFU234FormValidation = NFSFU234FormValidation;\r\n}\r\n\r\nexport default NFSFU234FormValidation","const LogLevelInterface = {\r\n    ERROR: 'error',\r\n    ERROR_1: 'error_1',\r\n    CONSOLE: 'console',\r\n    THROW: 'throw',\r\n    WARNING: 'warning',\r\n    INFO: 'info',\r\n  };\r\n  \r\nconst ExceptionHandler = (error: any, level: string = LogLevelInterface.CONSOLE) => {\r\n    switch (level) {\r\n\r\n      case LogLevelInterface.ERROR:\r\n        // You can customize error handling here\r\n        console.error('Error:', error);\r\n        // throw error;\r\n        // continue;\r\n        break;\r\n      \r\n      case LogLevelInterface.CONSOLE:\r\n        // You can customize error handling here\r\n        console.error('Error:', error);\r\n        break;\r\n\r\n      case LogLevelInterface.THROW:\r\n        throw error;\r\n\r\n      case LogLevelInterface.WARNING:\r\n        // You can customize warning handling here\r\n        console.warn('Warning:', error);\r\n        break;\r\n\r\n      case LogLevelInterface.INFO:\r\n        // You can customize info handling here\r\n        console.log('Info:', error);\r\n        break;\r\n\r\n      default:\r\n        // console.log(\"default\");\r\n        \r\n        // Default behavior is to treat as an error\r\n        console.error('Error:', error);\r\n        throw error;\r\n    }\r\n  };\r\n  \r\n  export { ExceptionHandler, LogLevelInterface };\r\n  ","/**\r\n * Check if All Elements are True\r\n *\r\n * This function checks if all elements in the given array are equal to true.\r\n *\r\n * @param {Array} arr - The array to be checked.\r\n * @returns {boolean} Returns true if all elements in the array are equal to true, otherwise false.\r\n */\r\nexport const areAllElementsTrue = (arr: Array<any>): boolean => {\r\n    // Use the 'every' method to check if every element in the array is equal to true\r\n    return arr.every(element => element === true);\r\n}\r\n\r\n/**\r\n * Count Length of Object\r\n *\r\n * This function calculates the number of properties (keys) in a given object.\r\n * @param {Object} object - The object for which the length is to be calculated.\r\n * @returns {number} Returns the number of properties (keys) in the object.\r\n */\r\nexport const countLengthOfObject = (object: object): number => {\r\n    // Return the number of keys in the object using Object.keys() and calculating its length\r\n    return Object.keys(object).length;\r\n}\r\n\r\n/**\r\n * Checks the data type of a variable and returns the corresponding type as a string.\r\n *\r\n * @param {*} variable - The variable to check the data type.\r\n * @returns {string} Returns the data type of the variable as a string.\r\n */\r\nexport const checkVariableType = (variable: any): string | null => {\r\n    // Check if the variable is a string\r\n    if (typeof variable === 'string') {\r\n        return 'string';\r\n    }\r\n    // Check if the variable is a number\r\n    else if (typeof variable === 'number') {\r\n        return 'number';\r\n    }\r\n    // Check if the variable is a boolean\r\n    else if (typeof variable === 'boolean') {\r\n        return 'boolean';\r\n    }\r\n    // Check if the variable is undefined\r\n    else if (typeof variable === 'undefined') {\r\n        return 'undefined';\r\n    }\r\n    // Check if the variable is null\r\n    else if (variable === null) {\r\n        return 'null';\r\n    }\r\n    // Check if the variable is an HTMLElement (assumes that HTMLElement is defined in the environment)\r\n    else if (variable instanceof HTMLElement) {\r\n        return 'HTML Element';\r\n    }\r\n    // Check if the variable is an array\r\n    else if (typeof variable === 'object' && variable instanceof Array) {\r\n        return 'array';\r\n    }\r\n    // Check if the variable is an object\r\n    else if (typeof variable === 'object' && variable instanceof Object) {\r\n        return 'object';\r\n    }\r\n    // Check if the variable is a function\r\n    else if (typeof variable === 'function') {\r\n        return 'function';\r\n    }\r\n    // If none of the above conditions match, the data type is unknown\r\n    else {\r\n        return null;\r\n    }\r\n}","import { ExceptionHandler } from \"../errorHandling/ExceptionHandler\";\r\n\r\nconst getPageUrl = ():string | boolean => {\r\n\r\n    if ( typeof window === 'undefined' )\r\n    {\r\n        ExceptionHandler('This function only works in a broswer environment...');\r\n        return false;\r\n    }\r\n\r\n    // Access the 'window' object and retrieve the current URL using 'window.location.href'.\r\n    // This will return the complete URL, including the protocol (http/https), domain, port, path, and query parameters.\r\n    return window.location.href;\r\n};\r\n\r\nexport default getPageUrl;","import { ExceptionHandler, LogLevelInterface } from \"../errorHandling/ExceptionHandler\";\r\nimport ErrorMessageInterface from \"../interfaces/ErrorMessagesInterface\";\r\nimport { checkVariableType } from \"../utilities\";\r\nimport getPageUrl from \"../utilities/getPageUrl\";\r\n\r\nconst makeAjaxRequest = async (url:string, options:any)   => {\r\n    let individualResponseMessage: ErrorMessageInterface = {};\r\n    try {\r\n        console.log(\"AJAX Loading....\");\r\n\r\n\r\n        let response = await fetch(url, options);\r\n\r\n        // console.log(response);\r\n        \r\n\r\n        if (response.ok) {\r\n            console.log(\"AJAX Finished....\");\r\n            return await response.json();\r\n            // try {\r\n            //     const responseData = await response.json();\r\n            //     console.log(responseData);\r\n        \r\n            //     if (checkVariableType(responseData) === 'object') {\r\n            //         individualResponseMessage.code = response.status;\r\n            //         individualResponseMessage.message = responseData.message || response.statusText;\r\n            //         individualResponseMessage.data = responseData;\r\n            //     } else {\r\n            //         individualResponseMessage.code = 400;\r\n            //         individualResponseMessage.message = \"Response is not a valid JSON object.\";\r\n            //         throw individualResponseMessage;\r\n            //     }\r\n        \r\n            //     return individualResponseMessage;\r\n            // } catch (error) {\r\n            //     // console.error(error);\r\n        \r\n            //     individualResponseMessage.code = 400;\r\n            //     individualResponseMessage.message = \"Response is not a valid JSON object.\";\r\n            //     individualResponseMessage.data = null;\r\n        \r\n            //     throw individualResponseMessage;\r\n            // }\r\n        } else {\r\n\r\n            if ( response.status === 404 )\r\n            {\r\n                individualResponseMessage.code = response.status ?? 404;\r\n                individualResponseMessage.message = \"Resource Not Found\";\r\n                individualResponseMessage.data = {\r\n                    headers: response.headers,\r\n                    url: response.url,\r\n                    status: response.status,\r\n                    statusText: response.statusText,\r\n                    ok: response.ok\r\n                };\r\n                throw individualResponseMessage;\r\n\r\n            }\r\n\r\n            // if (response.ok) {\r\n                // console.log(\"AJAX Finished....\");\r\n                // return await response.json();\r\n            // } else {\r\n                try {\r\n                    const responseData = await response.json();\r\n                    // console.log(responseData);\r\n            \r\n                    if (checkVariableType(responseData) === 'object') {\r\n                        individualResponseMessage.code = response.status;\r\n                        individualResponseMessage.message = responseData.message || response.statusText;\r\n                        individualResponseMessage.data = responseData;\r\n                    } else {\r\n\r\n                        // if ( response.status === 404 )\r\n                        // {\r\n                        //     individualResponseMessage.code = response.status;\r\n                        //     individualResponseMessage.message = response.statusText;\r\n                        //     individualResponseMessage.data = {\r\n                        //         headers: response.headers,\r\n                        //         url: response.url,\r\n                        //         status: response.status,\r\n                        //         statusText: response.statusText,\r\n                        //         ok: response.ok\r\n                        //     };\r\n                        //     throw individualResponseMessage;\r\n                \r\n                        // }\r\n\r\n                        individualResponseMessage.code = 400;\r\n                        individualResponseMessage.message = \"Response is not a valid JSON object 2.\";\r\n                        throw individualResponseMessage;\r\n                    }\r\n            \r\n                    return individualResponseMessage;\r\n                } catch (error: any) {\r\n                    // console.error(error);\r\n\r\n                    // if ( error.status === 404 )\r\n                    // {\r\n                    //     individualResponseMessage.code = error.status;\r\n                    //     individualResponseMessage.message = error.statusText;\r\n                    //     individualResponseMessage.data = {\r\n                    //         headers: error.headers,\r\n                    //         url: error.url,\r\n                    //         status: error.status,\r\n                    //         statusText: error.statusText,\r\n                    //         ok: error.ok\r\n                    //     };\r\n                    //     throw individualResponseMessage;\r\n            \r\n                    // }\r\n            \r\n                    individualResponseMessage.code = 400;\r\n                    individualResponseMessage.message = \"Response is not a valid JSON object. 1\";\r\n                    individualResponseMessage.data = null;\r\n            \r\n                    throw individualResponseMessage;\r\n                }\r\n            // }\r\n            \r\n\r\n            // try {\r\n                \r\n            //     response = await response.json();\r\n\r\n            //     console.log(response);\r\n                \r\n    \r\n            //     // throw new Error(\"AJAX Failed\");\r\n            //     // ExceptionHandler(\"AJAX FAILED\", \"error_1\")\r\n    \r\n            //     individualResponseMessage.code = response.status\r\n            //     individualResponseMessage.message = response.message || response.statusText\r\n            //     individualResponseMessage.data = null\r\n    \r\n            //     // console.log(individualResponseMessage);\r\n                \r\n            //     // ExceptionHandler(individualResponseMessage)\r\n    \r\n            //     // return individualResponseMessage\r\n            //     throw individualResponseMessage;\r\n    \r\n\r\n            // } catch (error) {\r\n                \r\n            //     individualResponseMessage.code = 400\r\n            //     individualResponseMessage.message = \"Response is not a valid JSON object.\"\r\n            //     individualResponseMessage.data = null\r\n\r\n            //     throw individualResponseMessage;\r\n    \r\n\r\n            // }\r\n\r\n           \r\n        }\r\n\r\n    } catch (error: any) {\r\n\r\n\r\n        // if ( error.status === 404 )\r\n        // {\r\n        //     individualResponseMessage.code = error.status;\r\n        //     individualResponseMessage.message = error.statusText;\r\n        //     individualResponseMessage.data = {\r\n        //         headers: error.headers,\r\n        //         url: error.url,\r\n        //         status: error.status,\r\n        //         statusText: error.statusText,\r\n        //         ok: error.ok\r\n        //     };\r\n        //     throw individualResponseMessage;\r\n\r\n        // }\r\n\r\n        // console.error(\"AJAX Error From Main Function:\", error.message);\r\n        individualResponseMessage.code = error.code || 400;\r\n        individualResponseMessage.message = error.message || error.statusText || \"An Error Occured\";\r\n        individualResponseMessage.data = error.data || null;\r\n\r\n        // console.log(individualResponseMessage);\r\n        \r\n\r\n        // throw individualResponseMessage;\r\n        throw individualResponseMessage;\r\n    }\r\n};\r\n\r\nconst prepareAjaxOptions = (AJAXOptions: any) => {\r\n    let individualResponseMessage: ErrorMessageInterface = {};\r\n    const method = AJAXOptions.RequestMethod || 'GET';\r\n    const headers = AJAXOptions.RequestHeader || {};\r\n    const ignoreBodyMessage = AJAXOptions.RequestBodyIgnore || false;\r\n    const type = AJAXOptions.RequestType || 'json';\r\n\r\n    let body;\r\n    if (['POST', 'PUT', 'DELETE', 'UPDATE'].includes(method)) {\r\n        body = AJAXOptions.RequestBody || '';\r\n\r\n        if ( body === '' && ignoreBodyMessage !== true )\r\n        {\r\n            individualResponseMessage.code = 400\r\n            individualResponseMessage.message = `The body of this \"${method}\" request you made is empty. If this was intentionional, then add the RequestBodyIgnore attribute and set it to true.`;\r\n            throw individualResponseMessage;\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n    return {\r\n        method,\r\n        headers,\r\n        body: JSON.stringify(body)\r\n    };\r\n};\r\n\r\nconst ajax = async (AJAXOptions: any) => {\r\n    let individualResponseMessage: ErrorMessageInterface = {};\r\n    try {\r\n        const url = AJAXOptions && AJAXOptions.url ? AJAXOptions.url : getPageUrl();\r\n        const options = prepareAjaxOptions(AJAXOptions);\r\n        const responseData = await makeAjaxRequest(url, options);\r\n\r\n        return responseData;\r\n    } catch (error:any) {\r\n\r\n        \r\n\r\n        // console.error(\"AJAX Error From Main Function:\", error);\r\n        individualResponseMessage.code = error.code || 400;\r\n        individualResponseMessage.message = error.message ||  \"An Error Occured\";\r\n        individualResponseMessage.data = error.data ?? null;\r\n\r\n        // console.log(individualResponseMessage);\r\n\r\n        // console.error(\"AJAX ERROR: \", error);\r\n        console.error(\"AJAX Failed: \", error.message);\r\n\r\n        ExceptionHandler(error.message, LogLevelInterface.THROW)\r\n\r\n        // return individualResponseMessage;\r\n        throw error;\r\n    }\r\n};\r\n\r\nexport default ajax;\r\n","const focusInputElement = (inputElement: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement, duration: number = 3000) => {\r\n\r\n    // Set focus on the specified input element to bring it into focus.\r\n    inputElement.focus();\r\n\r\n    // Add the 'input-focus-error' CSS class to the input element to apply the temporary highlighting effect.\r\n    inputElement.classList.add('input-focus-error');\r\n\r\n    // After the specified duration, remove the 'input-focus-error' CSS class to revert the highlighting effect.\r\n    setTimeout(() => {\r\n        inputElement.classList.remove('input-focus-error');\r\n    }, duration);\r\n\r\n};\r\n\r\nexport default focusInputElement;","import focusInputElement from \"../utilities/focusInputElement\";\r\n\r\n/**\r\n * displayErrorInline\r\n * \r\n * This function displays an error message inline next to an input field on a login page.\r\n * The error message is shown for a specified duration and can also be a success message.\r\n * \r\n * @param {HTMLElement} inputField - The input field element where the error message will be displayed.\r\n * @param {string} message - The error message to be displayed.\r\n * @param {number} duration - The duration (in milliseconds) for which the error message is visible inline. Default: 3000 ms.\r\n * @param {boolean} isSuccess - A flag indicating if the message is a success message (true) or an error message (false). Default: false.\r\n */\r\nconst displayErrorInline = (inputField: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement, message: string, duration: number = 3000, isSuccess: boolean = false) => {\r\n\r\n    if ( ! inputField )\r\n    {\r\n        return false;\r\n    }\r\n\r\n    // Focus on the input field and temporarily highlight it using the _focusInputElement function.\r\n    focusInputElement(inputField, duration);\r\n\r\n    // Create the inline error message container element.\r\n    const errorMessageContainer = document.createElement('div');\r\n    errorMessageContainer.classList.add('js-inline-message');\r\n\r\n    // Set the error message content inside the container.\r\n    errorMessageContainer.innerHTML = message;\r\n\r\n    const parentNode = inputField.parentNode;\r\n\r\n    if ( ! parentNode )\r\n    {\r\n        return false;\r\n    }\r\n\r\n    // Append the error message container to the parent of the input tag, placing it inline next to the input field.\r\n    parentNode.appendChild(errorMessageContainer);\r\n\r\n    // Add the 'text-success' class to the container if it's a success message, making it visually distinct.\r\n    if (isSuccess) {\r\n        \r\n        errorMessageContainer.classList.add('text-success');\r\n    }\r\n\r\n    // After the specified duration, remove the error message container to hide the message.\r\n    setTimeout(() => {\r\n        parentNode.removeChild(errorMessageContainer);\r\n    }, duration);\r\n}\r\n\r\nexport default displayErrorInline;","/**\r\n * displayErrorModal\r\n *\r\n * This function displays an error message in a modal-like container for a specified duration.\r\n * The error message can be customized to indicate success (green color) or failure (red color).\r\n * If a custom error container ID is provided, the error message is appended to that container;\r\n * otherwise, it creates a new container and appends it to the form.\r\n *\r\n * @param {string} message - The error message to display.\r\n * @param {HTMLElement} form - The form element to which the error message will be added.\r\n * @param {string} errorContainerId - Optional. The ID of the custom error container.\r\n * @param {number} duration - Optional. The duration (in milliseconds) for which the error message is visible. Default: 3000 ms.\r\n * @param {boolean} isSuccess - Optional. If true, the message is displayed as a success message (green color). Default: false.\r\n * @param {boolean} shouldLogToConsole - Optional. If true, the error message is logged to the console. Default: false.\r\n */\r\nconst displayErrorModal = (message: string, form: HTMLElement | HTMLDivElement, errorContainerId: string = '', duration: number = 3000, isSuccess: boolean = false, shouldLogToConsole: boolean = false) => {\r\n\r\n    // Determine the error container based on the provided ID or create a new one if not available\r\n    var errorMessageParentContainer;\r\n\r\n    if (errorContainerId != '') {\r\n        errorMessageParentContainer = document.getElementById(errorContainerId);\r\n    } else if (document.querySelectorAll('#js-errorMessageContainer').length > 0) {\r\n        errorMessageParentContainer = form.querySelector('#js-errorMessageContainer');\r\n    } else {\r\n        errorMessageParentContainer = document.createElement('div');\r\n        errorMessageParentContainer.classList.add('js-errorMessageContainer');\r\n        errorMessageParentContainer.setAttribute('id', 'js-errorMessageContainer');\r\n        form.appendChild(errorMessageParentContainer);\r\n    }\r\n\r\n    if (! errorMessageParentContainer)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    // Create the error message container and append it to the error container parent\r\n    var errorMessageContainer = document.createElement('div');\r\n    errorMessageContainer.classList.add('login-error-message-container', 'active');\r\n\r\n    var errorMessageMessageContainer = document.createElement('div');\r\n    errorMessageMessageContainer.classList.add('message', 'js-message');\r\n    errorMessageMessageContainer.innerHTML = message;\r\n\r\n    const errorMessageIconContainer = document.createElement('div');\r\n    errorMessageIconContainer.classList.add('icon', 'close', 'js-close');\r\n    errorMessageIconContainer.innerHTML = \"<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><path d='M15.71,8.29a1,1,0,0,0-1.42,0L12,10.59,9.71,8.29A1,1,0,0,0,8.29,9.71L10.59,12l-2.3,2.29a1,1,0,0,0,0,1.42,1,1,0,0,0,1.42,0L12,13.41l2.29,2.3a1,1,0,0,0,1.42,0,1,1,0,0,0,0-1.42L13.41,12l2.3-2.29A1,1,0,0,0,15.71,8.29Zm3.36-3.36A10,10,0,1,0,4.93,19.07,10,10,0,1,0,19.07,4.93ZM17.66,17.66A8,8,0,1,1,20,12,7.95,7.95,0,0,1,17.66,17.66Z'/></svg>\";\r\n\r\n    errorMessageContainer.appendChild(errorMessageMessageContainer);\r\n    errorMessageContainer.appendChild(errorMessageIconContainer);\r\n\r\n    errorMessageParentContainer.appendChild(errorMessageContainer);\r\n\r\n    // Optionally, set the success class to display the message in green color\r\n    if (isSuccess) {\r\n        errorMessageContainer.classList.add('success');\r\n    }\r\n\r\n    // Listens to when the user clicks on the close button of an error message container\r\n    const errorMessageContainerCloseBtn = errorMessageContainer.querySelector('.js-close');\r\n\r\n    if (! errorMessageContainerCloseBtn)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    errorMessageContainerCloseBtn.addEventListener('click', () => {\r\n        if (errorMessageContainer && errorMessageContainer.parentNode) {\r\n            errorMessageContainer.parentNode.removeChild(errorMessageContainer);\r\n        }\r\n    });\r\n\r\n    // Set timeout to remove the error message container after the specified duration\r\n    setTimeout(() => {\r\n        if (errorMessageContainer && errorMessageContainer.parentNode) {\r\n            errorMessageContainer.parentNode.removeChild(errorMessageContainer);\r\n        }\r\n    }, duration);\r\n\r\n    // Optionally, log the error message to the console\r\n    if (shouldLogToConsole) {\r\n        console.error(message);\r\n    }\r\n}\r\n\r\n\r\nexport default displayErrorModal;","import displayErrorInline from \"./displayErrorInline\";\r\nimport displayErrorModal from \"./displayErrorModal\";\r\n\r\n/**\r\n * Display an error message in the specified manner.\r\n *\r\n * @param {Object} details - The details of the error message.\r\n * @param {string} details.type - The type of error display (either 'inline' or 'modal').\r\n * @param {string} details.message - The error message to be displayed.\r\n * @param {number} details.duration - The duration for which the error message should be visible.\r\n * @param {HTMLElement} details.element - The HTML element to which the error message is associated.\r\n * @param {boolean} [details.success=false] - A flag indicating whether the operation was successful.\r\n * @returns {boolean} Returns true if the error message was displayed successfully, false otherwise.\r\n */\r\nconst displayError = (details: {\r\n    type: string;\r\n    message: string;\r\n    duration: number;\r\n    element: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement;\r\n    success?: boolean;\r\n}): boolean => {\r\n    // Destructure the details object\r\n    const { type, message, duration, element, success = false } = details;\r\n\r\n    // Check if the element is a valid HTML element\r\n    if (!(element instanceof HTMLElement)) {\r\n        console.error(\"The HTML Element you are trying to use is not found.\");\r\n        return false;\r\n    }\r\n\r\n    // Set the 'position' property of 'element' to 'relative'\r\n    element.style.position = 'relative';\r\n\r\n    // Determine the type of error display and invoke the appropriate function\r\n    if (type === 'inline') {\r\n        displayErrorInline(element, message, duration, success);\r\n    } else if (type === 'modal') {\r\n        displayErrorModal(message, element, '', duration, success);\r\n    } else {\r\n        // Display an error message for unsupported error display types\r\n        console.error(\"The type of error display you specified is not supported.\");\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\n\r\nexport default displayError;","import { ExceptionHandler } from \"../errorHandling/ExceptionHandler\";\r\nimport ErrorMessageInterface from \"../interfaces/ErrorMessagesInterface\";\r\nimport { areAllElementsTrue } from \"../utilities\";\r\n\r\n/**\r\n * Retrieves data from the provided form element.\r\n * Collects data from input fields, textareas, and select elements with the specified attribute 'data-attr-name'.\r\n * The collected data is stored in an object with attribute names as keys and corresponding input values as values.\r\n * @param {HTMLFormElement | HTMLDivElement | string} u_form - The HTML form element or its ID from which to extract data.\r\n * @returns {Object | boolean} - Returns an object containing form data if successful, or false if the form is not valid or no data is found.\r\n */\r\nconst getFormDetails = (u_form: HTMLFormElement | HTMLDivElement | string): Record<string, string | boolean> | boolean | ErrorMessageInterface => {\r\n    let individualResponseMessage: ErrorMessageInterface = { message: \"\", type: 'error', code : 400 };\r\n\r\n    // Check if running in a browser environment\r\n    if (typeof window === 'undefined') {\r\n        console.error(\"To access this function, you will need to execute it in a browser like Google Chrome, Safari, Firefox, Microsoft Edge, etc.\");\r\n        ExceptionHandler(\"To access this function, you will need to execute it in a browser like Google Chrome, Safari, Firefox, Microsoft Edge, etc.\");\r\n        return false;\r\n    }\r\n    \r\n\r\n    // Check if the form element is provided\r\n    if ( ! u_form )\r\n    {\r\n\r\n        individualResponseMessage.message = \"The form you are trying to validate does not exist.\";\r\n        ExceptionHandler(\"The form you are trying to validate does not exist.\")\r\n        return individualResponseMessage;\r\n\r\n    }\r\n\r\n    // Resolve form element by ID if it's a string\r\n    const form = typeof u_form === 'string' ? document.getElementById(u_form) : u_form;\r\n    \r\n    // Check if the form element is provided\r\n    if ( ! form )\r\n    {\r\n\r\n        individualResponseMessage.message = \"The form you are trying to validate does not exist.\";\r\n        ExceptionHandler(\"The form you are trying to validate does not exist.\");\r\n        return individualResponseMessage;\r\n\r\n    }\r\n\r\n    const requestData: Record<string, string | boolean> = {}; // Initialize object to store form data\r\n    const shouldContinue: boolean[] = []; // Track extraction process success\r\n\r\n    // Extract data from input fields\r\n    const allInputsInForm = form.querySelectorAll('input');\r\n    allInputsInForm.forEach((input: HTMLInputElement, index: number) => {\r\n        const attributeName = input.getAttribute('data-attr-name') || input.getAttribute('name') || index;\r\n        let inputValue: string | boolean = input.value;\r\n\r\n        // Handle checkbox inputs\r\n        if (input.type === 'checkbox') {\r\n            inputValue = input.checked;\r\n        }\r\n\r\n        // Handle radio inputs\r\n        if (input.type === 'radio') {\r\n            if (input.checked) {\r\n                inputValue = true;\r\n            } else {\r\n                return; // Skip unchecked radio buttons\r\n            }\r\n        }\r\n\r\n        requestData[attributeName] = inputValue; // Store input value in requestData\r\n        shouldContinue.push(true);\r\n    });\r\n\r\n    // Extract data from textareas\r\n    const allTextareasInForm = form.querySelectorAll('textarea');\r\n    allTextareasInForm.forEach((textarea: HTMLTextAreaElement, index: number) => {\r\n        const attributeName = textarea.getAttribute('data-attr-name') || textarea.getAttribute('name') || index;\r\n        const textareaValue = textarea.value;\r\n\r\n        requestData[attributeName] = textareaValue; // Store textarea value in requestData\r\n        shouldContinue.push(true);\r\n    });\r\n\r\n    // Extract data from select elements\r\n    const allSelectsInForm = form.querySelectorAll('select');\r\n    allSelectsInForm.forEach((select: HTMLSelectElement, index: number) => {\r\n        const attributeName = select.getAttribute('data-attr-name') || select.getAttribute('name') || index;\r\n        const selectValue = select.value;\r\n\r\n        requestData[attributeName] = selectValue; // Store select value in requestData\r\n        shouldContinue.push(true);\r\n    });\r\n\r\n    // Check if all elements in the form extraction process were successful\r\n    if (areAllElementsTrue(shouldContinue)) {\r\n        return requestData; // Return the object containing the form data\r\n    } else {\r\n        return false; // Return false if any part of the form extraction process failed\r\n    }\r\n};\r\n\r\nexport default getFormDetails;\r\n","const countString = (str: string): number => {\r\n    return str.length;\r\n};\r\n\r\nexport default countString;","import { ExceptionHandler } from \"../errorHandling/ExceptionHandler\";\r\nimport ErrorMessageInterface from \"../interfaces/ErrorMessagesInterface\";\r\nimport { checkVariableType } from \"../utilities\";\r\nimport countString from \"../utilities/countString\";\r\n\r\n/**\r\n * Count input characters and restrict input while typing in a given input element.\r\n * @param {HTMLInputElement} inputElement - The HTML input element to count and restrict.\r\n * @param {HTMLElement} [counterContainer] - Optional container to display the character count. If not provided, it creates one automatically.\r\n * @param {Object} [options={}] - An object with the following optional properties:\r\n *   - maxLength {number}: Maximum allowed characters (default: 250).\r\n *   - minLength {number}: Minimum allowed characters (default: 0).\r\n *   - shouldButtonDisable {boolean}: Flag to determine whether to disable buttons on reaching maxLength (default: false).\r\n *   - formId {string}: The ID of the form element associated with the input.\r\n * @returns {boolean} Return true if the input meets the restrictions, otherwise false.\r\n */\r\nconst restrictInputLengthWithCounter = (inputElement: HTMLInputElement | HTMLTextAreaElement,  options: any = {}, counterContainer?: HTMLElement | string): any => {\r\n\r\n    let individualResponseMessage: ErrorMessageInterface = { message: \"\", code : 400 };\r\n\r\n\r\n    // Check if the input element exists.\r\n    if (!inputElement) {\r\n        // console.error(\"The input element you are trying to count and restrict is not found. Check your HTML code.\");\r\n        individualResponseMessage.message = \"The input element you are trying to count and restrict is not found. Check your HTML code.\"\r\n        ExceptionHandler(individualResponseMessage.message);\r\n        return individualResponseMessage;\r\n    }\r\n\r\n    // Extract options or set default values.\r\n    const maxLength = (options['maxLength'] && parseInt(options['maxLength']) && options['maxLength'] >= 1) ? options['maxLength'] : 250;\r\n    const minLength = (options['minLength'] && parseInt(options['minLength'])) ? options['minLength'] : 0;\r\n    const shouldButtonDisable = (options['shouldButtonDisable'] && options['shouldButtonDisable']) ? true : false;\r\n\r\n    let form;\r\n\r\n    if ( options.form && checkVariableType(options.form) === 'string' )\r\n    {\r\n        document.getElementById(options.form)\r\n    }\r\n    else if ( options.form && checkVariableType(options.form) === 'HTML Element' )\r\n    {\r\n        form = options.form\r\n    }\r\n    else\r\n    {\r\n\r\n        \r\n        if ( document.getElementById(\"nfsfu234_fv_form\") )\r\n        {\r\n            form = document.getElementById(\"nfsfu234_fv_form\");\r\n        }\r\n        else if ( document.getElementById(\"jsForm\") )\r\n        {\r\n            form = document.getElementById(\"jsForm\");\r\n        }\r\n        else if ( document.querySelector(\"form\") )\r\n        {\r\n            form = document.querySelector(\"form\");\r\n        }\r\n        else\r\n        {\r\n            form = undefined\r\n        }\r\n\r\n    }\r\n\r\n    // Check if the form element exists\r\n    if (!form) {\r\n        individualResponseMessage.message = \"The form you are trying to validate does not exist.\";\r\n        ExceptionHandler(individualResponseMessage.message);\r\n        return individualResponseMessage;\r\n    }\r\n\r\n    // Add an event listener to the input element for counting and restricting.\r\n    inputElement.addEventListener('input', () => {\r\n        // Count the number of characters in the input element.\r\n        var textLength = countString(inputElement.value);\r\n        var returnMessage = false;\r\n\r\n        // Check if a counter container is provided or create one if not.\r\n        var counterElement: any;\r\n\r\n        if ( checkVariableType(counterContainer) === 'string' )\r\n        {\r\n\r\n            counterElement = document.getElementById(counterContainer as string)\r\n\r\n        }\r\n\r\n        if (!counterElement) {\r\n            const parentNode = inputElement.parentNode;\r\n\r\n            if ( parentNode?.querySelector(\".js-counterContainer\") )\r\n            {\r\n                counterElement = parentNode.querySelector(\".js-counterContainer\")\r\n            }\r\n            else\r\n            {\r\n                counterElement = document.createElement('span');\r\n                counterElement.classList.add('js-counterContainer');\r\n                if (! parentNode)\r\n                {\r\n                    return false;\r\n                }\r\n                parentNode.appendChild(counterElement);\r\n            }\r\n\r\n            \r\n        } else {\r\n            counterElement = counterElement;\r\n        }\r\n\r\n        if ( ! counterElement )\r\n        {\r\n            individualResponseMessage.message = \"Counter Element Not Found\";\r\n            ExceptionHandler(individualResponseMessage.message)\r\n            return individualResponseMessage;\r\n        }\r\n\r\n        // Apply restrictions based on character count and options.\r\n        if (textLength > maxLength) {\r\n            textLength = maxLength;\r\n            counterElement.classList.remove('text-fail');\r\n            counterElement.classList.add('text-success');\r\n            inputElement.value = inputElement.value.slice(0, maxLength);\r\n\r\n            // Enable buttons in the associated form (if specified).\r\n            if (shouldButtonDisable && form) {\r\n                form.querySelectorAll('button').forEach((button: HTMLButtonElement) => {\r\n                    button.disabled = false;\r\n                });\r\n            }\r\n\r\n            returnMessage = true;\r\n        } else if (textLength >= maxLength) {\r\n            inputElement.value = inputElement.value.slice(0, maxLength);\r\n            counterElement.classList.remove('text-fail');\r\n            counterElement.classList.add('text-success');\r\n\r\n            // Enable buttons in the associated form (if specified).\r\n            if (shouldButtonDisable && form) {\r\n                form.querySelectorAll('button').forEach((button: HTMLButtonElement) => {\r\n                    button.disabled = false;\r\n                });\r\n            }\r\n\r\n            returnMessage = true;\r\n        } else if (textLength >= minLength && minLength !== 0) {\r\n            counterElement.classList.remove('text-fail');\r\n            counterElement.classList.add('text-success');\r\n\r\n            // Enable buttons in the associated form (if specified).\r\n            if (shouldButtonDisable && form) {\r\n                form.querySelectorAll('button').forEach((button: HTMLButtonElement) => {\r\n                    button.disabled = false;\r\n                });\r\n            }\r\n\r\n            returnMessage = true;\r\n        } else {\r\n            counterElement.classList.add('text-fail');\r\n\r\n            // Enable buttons in the associated form (if specified).\r\n            if (shouldButtonDisable && form) {\r\n                form.querySelectorAll('button').forEach((button: HTMLButtonElement) => {\r\n                    button.disabled = false;\r\n                });\r\n            }\r\n        }\r\n\r\n        // Update the counter element with the current character count.\r\n        counterElement.innerHTML = `${textLength}/${maxLength}`;\r\n\r\n        return returnMessage;\r\n    });\r\n\r\n};\r\n\r\nexport default restrictInputLengthWithCounter;","// Check if a string contains only integers.\r\nconst containsOnlyIntegers = (str: string | number): boolean => {\r\n    return /^\\d+$/.test(str as string);\r\n};\r\n\r\nexport default containsOnlyIntegers;","interface DateFormat {\r\n    [key: string]: RegExp;\r\n}\r\n\r\nconst formats: DateFormat = {\r\n    \"dd/mm/yyyy\": /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$/,\r\n    \"yyyy-mm-dd\": /^\\d{4}-\\d{2}-\\d{2}$/,\r\n    \"mm/dd/yyyy\": /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$/,\r\n    \"mm.dd.yyyy\": /^\\d{1,2}\\.\\d{1,2}\\.\\d{4}$/,\r\n    \"yyyy/mm/dd\": /^\\d{4}\\/\\d{1,2}\\/\\d{1,2}$/,\r\n    \"yyyy.mm.dd\": /^\\d{4}\\.\\d{1,2}\\.\\d{1,2}$/,\r\n    \"time\": /^(0?[1-9]|1[0-2]):[0-5][0-9] (AM|PM)$/, // 12-hour format\r\n    \"24-hour\": /^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$/, // 24-hour format\r\n    \"month\": /^(0?[1-9]|1[0-2])$/, // Month only\r\n    \"day\": /^(0?[1-9]|[1-2][0-9]|3[0-1])$/, // Day only\r\n    // Add more formats as needed\r\n};\r\n\r\nconst isDate = (value: string, format: string = \"dd/mm/yyyy\"): boolean => {\r\n    const regex = formats[format.toLowerCase()];\r\n    if (!regex) {\r\n        console.error(`Invalid date format: ${format}`);\r\n        return false;\r\n    }\r\n\r\n    return regex.test(value);\r\n};\r\n\r\n// Example usage\r\n// console.log(isDate(\"31/12/2022\", \"dd/mm/yyyy\")); // true\r\n// console.log(isDate(\"12/31/2022\", \"mm/dd/yyyy\")); // true\r\n// console.log(isDate(\"2022-12-31\", \"yyyy-mm-dd\")); // true\r\n// console.log(isDate(\"12.31.2022\", \"mm.dd.yyyy\")); // true\r\n// console.log(isDate(\"2022/12/31\", \"yyyy/mm/dd\")); // true\r\n// console.log(isDate(\"2022.12.31\", \"yyyy.mm.dd\")); // true\r\n// console.log(isDate(\"12:30 PM\", \"time\")); // true\r\n// console.log(isDate(\"23:45\", \"24-hour\")); // true\r\n// console.log(isDate(\"5\", \"month\")); // true\r\n// console.log(isDate(\"15\", \"day\")); // true\r\n\r\n\r\nexport default isDate;\r\n","// Function to validate email format\r\nconst isEmail = (value: string): boolean => {\r\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n    return emailRegex.test(value);\r\n};\r\n\r\nexport default isEmail;","const isURL = (url:string) => {\r\n\r\n    // Regular expression to check for 'http://' or 'https://' at the beginning\r\n    // and support formats like https://www.domain.com/ or https://domain.com/ or https://www.domain.com/?param1=1&param2=2\r\n    const urlPattern = /^(https?:\\/\\/)?(www\\.)?[a-zA-Z0-9-]+\\.[a-zA-Z]{2,}(:\\d{1,5})?(\\/[^\\s]*)?(\\?.*)?$/;\r\n\r\n    // If the input is a string, test it against the regular expression.\r\n    return typeof url === 'string' ? urlPattern.test(url) : false;\r\n\r\n};\r\n\r\nexport default isURL;","/**\r\n * Checks if the provided value is a valid ZIP code.\r\n * @param {string | number} zipCode - The ZIP code to validate.\r\n * @returns {boolean} - Returns true if the ZIP code is valid, otherwise false.\r\n */\r\nconst isZIP = (zipCode: string | number): boolean => {\r\n    // Convert zipCode to a string if it's a number\r\n    if (typeof zipCode === 'number') {\r\n        zipCode = zipCode.toString() as string;\r\n    }\r\n\r\n    // Regular expression to match ZIP codes with exactly 5 or 6 digits\r\n    const zipCodeRegex = /^\\d{5}(?:\\d{1})?$/;\r\n    return zipCodeRegex.test(zipCode);\r\n};\r\n\r\nexport default isZIP;\r\n","import { ExceptionHandler } from \"../errorHandling/ExceptionHandler\";\r\nimport displayErrorInline from \"../errorHandling/displayErrorInline\";\r\nimport displayErrorModal from \"../errorHandling/displayErrorModal\";\r\nimport ErrorMessageInterface from \"../interfaces/ErrorMessagesInterface\";\r\nimport focusInputElement from \"../utilities/focusInputElement\";\r\n\r\n/**\r\n * Validates a checkbox input field.\r\n * @param {HTMLInputElement} checkboxInputField - The checkbox input field to validate.\r\n * @param {object} customErrorMessage - Custom error messages for checkbox validation.\r\n * @param {boolean} isErrorInline - Flag indicating whether to display the error message inline or in a modal.\r\n * @param {HTMLFormElement} form - The form element containing the checkbox input.\r\n * @returns {boolean} - Returns true if the checkbox input is valid or not required, otherwise false.\r\n */\r\nfunction validateCheckbox(\r\n    checkboxInputField: HTMLInputElement,\r\n    options: any,\r\n    callback?: any\r\n): boolean  | ErrorMessageInterface {\r\n    let individualResponseMessage: ErrorMessageInterface = { message: \"\", type: 'error', code : 400 };\r\n\r\n    // Check if running in a browser environment\r\n    if (typeof window === 'undefined') {\r\n        console.error(\"To access this function, you will need to execute it in a browser like Google Chrome, Safari, Firefox, Microsoft Edge, etc.\");\r\n        ExceptionHandler(\"To access this function, you will need to execute it in a browser like Google Chrome, Safari, Firefox, Microsoft Edge, etc.\", 'big')\r\n        return false;\r\n    }\r\n\r\n    const form: HTMLFormElement | HTMLDivElement | undefined = options.form || undefined;\r\n    const customErrorMessage: any = options.customErrorMessages || null;\r\n    const errorType: string = options.errorType || 'inline'\r\n    const includeHTML = options.includeHTML === false ? false : true;\r\n\r\n\r\n    const isRequired: boolean = checkboxInputField.hasAttribute('required') || checkboxInputField.classList.contains('js-required');\r\n\r\n    const errorMessage: string = (customErrorMessage && customErrorMessage['checkbox'] && customErrorMessage['checkbox'] !== '') ?\r\n    customErrorMessage['checkbox'] : 'You need to check this box';\r\n\r\n    // Check if the input field is a checkbox\r\n    if (checkboxInputField.getAttribute('type') !== 'checkbox') {\r\n        return false; // Not a checkbox, return false\r\n    }\r\n\r\n    if ( ! includeHTML )\r\n    {\r\n\r\n        // Perform the validation for the select field\r\n        if (isRequired && ! checkboxInputField.checked) {\r\n\r\n            ExceptionHandler(errorMessage)\r\n\r\n            individualResponseMessage.message = errorMessage;\r\n            individualResponseMessage.data = checkboxInputField\r\n\r\n            return individualResponseMessage; // Validation failed\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    if ( ! form )\r\n    {\r\n\r\n        individualResponseMessage.message = \"The form you are trying to validate does not exist.\";\r\n        ExceptionHandler(\"The form you are trying to validate does not exist. 5765846846\")\r\n        return individualResponseMessage;\r\n\r\n    }\r\n\r\n    const shouldContinue: boolean[] = [];\r\n\r\n    // If the checkbox is required and not checked\r\n    if (isRequired && ! checkboxInputField.checked) {\r\n\r\n\r\n        ExceptionHandler(errorMessage)\r\n\r\n        individualResponseMessage.message = errorMessage;\r\n        individualResponseMessage.data = checkboxInputField\r\n\r\n        // Display the error message inline or in a modal based on the isErrorInline flag\r\n        if (errorType === 'inline') {\r\n            displayErrorInline(checkboxInputField, errorMessage, 3000);\r\n        } else if (errorType === 'modal') {\r\n            focusInputElement(checkboxInputField, 3000);\r\n            displayErrorModal(errorMessage, form);\r\n        }\r\n\r\n        // shouldContinue.push(false); // Mark the validation as unsuccessful\r\n        return individualResponseMessage; // Validation failed\r\n    } else {\r\n        // shouldContinue.push(true); // Mark the validation as successful\r\n        return true; // Checkbox is valid or not required\r\n    }\r\n\r\n}\r\n\r\nexport default validateCheckbox;\r\n","import { ExceptionHandler } from \"../errorHandling/ExceptionHandler\";\r\nimport displayErrorInline from \"../errorHandling/displayErrorInline\";\r\nimport displayErrorModal from \"../errorHandling/displayErrorModal\";\r\nimport ErrorMessageInterface from \"../interfaces/ErrorMessagesInterface\";\r\nimport { areAllElementsTrue, checkVariableType } from \"../utilities\";\r\nimport focusInputElement from \"../utilities/focusInputElement\";\r\n\r\n/**\r\n * Validates a single radio input or a group of radio inputs.\r\n * @param {HTMLInputElement | string} radioInputField - The radio input element or its name attribute.\r\n * @param {object} customErrorMessage - Custom error message for radio validation.\r\n * @returns {boolean} - Returns true if the radio input(s) are valid, otherwise false.\r\n */\r\nconst validateRadio = (\r\n    radioInputField: HTMLInputElement | string,  \r\n    options: any,\r\n    callback?: any\r\n): boolean | string | ErrorMessageInterface => {\r\n\r\n    // Check if running in a browser environment\r\n    if (typeof window === 'undefined') {\r\n        console.error(\"To access this function, it must be executed in a browser environment.\");\r\n        ExceptionHandler(\"To access this function, you will need to execute it in a browser like Google Chrome, Safari, Firefox, Microsoft Edge, etc.\", 'big')\r\n        return false;\r\n    }\r\n\r\n    let individualResponseMessage: ErrorMessageInterface = { message: \"an error occured\", type: 'error', code : 400 };\r\n\r\n    const form: HTMLFormElement | HTMLDivElement | undefined = options.form || undefined;\r\n    const customErrorMessages: any = options.customErrorMessages || null;\r\n    let errorMessage = customErrorMessages['checkbox'] ?? 'You need to choose a value.';\r\n\r\n    \r\n    if ( ! form )\r\n    {\r\n\r\n        individualResponseMessage.message = \"The form you are trying to validate does not exist.\";\r\n        ExceptionHandler(\"The form you are trying to validate does not exist. 5765846846\")\r\n        return individualResponseMessage;\r\n\r\n    }\r\n\r\n    let radioName: string | null = null;\r\n\r\n    // Determine the radio group name\r\n    if (typeof radioInputField === 'object' && radioInputField instanceof HTMLInputElement) {\r\n        radioName = radioInputField.getAttribute('name');\r\n    } else if (typeof radioInputField === 'string') {\r\n        radioName = radioInputField;\r\n    } else {\r\n\r\n        // Check if the select field is valid and exists in the DOM\r\n        if (!radioInputField) {\r\n            console.error(\"The radio element(s) to validate is(are) not found.\");\r\n            individualResponseMessage.message = \"The radio element(s) to validate is(are) not found.\";\r\n            return individualResponseMessage;\r\n        }\r\n\r\n    }\r\n\r\n    if ( ! radioName )\r\n    {\r\n        ExceptionHandler(\"The radio element(s) to validate is(are) not found.\");\r\n        individualResponseMessage.message = \"The radio element(s) to validate is(are) not found.\";\r\n        return individualResponseMessage;\r\n    }\r\n\r\n    // Get all radio inputs within the same group\r\n    const radioGroup: NodeListOf<HTMLInputElement> = document.querySelectorAll(`input[type=\"radio\"][name=\"${radioName}\"]`);\r\n    let isRequired: boolean = false;\r\n    let isAnyRadioChecked: boolean = false;\r\n    const errorType: string = options.errorType || 'inline'\r\n    const shouldContinue: boolean[] = [];\r\n    let radioInput: any  = null;\r\n\r\n    // Iterate over each radio input in the group\r\n    radioGroup.forEach((radio: HTMLInputElement) => {\r\n\r\n        radioInput = radio\r\n\r\n        // Check if the radio input is required or has a class \"js-required\"\r\n        if (radio.required || radio.classList.contains('js-required')) {\r\n\r\n            isRequired = true;\r\n\r\n            if (radio.checked) {\r\n\r\n                // isAnyRadioChecked = true;\r\n                shouldContinue.push(true);\r\n            }\r\n            else\r\n            {\r\n\r\n                shouldContinue.push(false);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    });\r\n\r\n\r\n    // Check if all validation results are the same (either all true or all false)\r\n    const checkIfAllElementsAreTrue = areAllElementsTrue(shouldContinue);\r\n\r\n    if ( checkIfAllElementsAreTrue )\r\n    {\r\n        return true;\r\n    }\r\n\r\n    const ignoreError = options.ignoreError && options.ignoreError === true ? true : false;\r\n\r\n    \r\n\r\n    if ( ! ignoreError )\r\n    {\r\n\r\n        \r\n\r\n        // Display the error message inline or in a modal based on the isErrorInline flag\r\n        if (errorType === 'inline') {\r\n            displayErrorInline(radioInput as HTMLInputElement, errorMessage, 3000);\r\n        } else if (errorType === 'modal') {\r\n            focusInputElement(radioInput  as HTMLInputElement, 3000);\r\n            displayErrorModal(errorMessage, form);\r\n        }\r\n\r\n\r\n    }\r\n\r\n    individualResponseMessage.message = \"You need to choose a value.\";\r\n    individualResponseMessage.data = radioInput\r\n\r\n    // console.error(\"luytoyfouytvctrusatdf: \", individualResponseMessage);\r\n    \r\n\r\n    return individualResponseMessage;\r\n\r\n};\r\n\r\nexport default validateRadio;\r\n","import { ExceptionHandler } from \"../errorHandling/ExceptionHandler\";\r\nimport displayErrorInline from \"../errorHandling/displayErrorInline\";\r\nimport displayErrorModal from \"../errorHandling/displayErrorModal\";\r\nimport ErrorMessageInterface from \"../interfaces/ErrorMessagesInterface\";\r\nimport { checkVariableType } from \"../utilities\";\r\nimport containsOnlyIntegers from \"../utilities/containsOnlyIntegers\";\r\nimport focusInputElement from \"../utilities/focusInputElement\";\r\nimport isDate from \"../utilities/isDate\";\r\nimport isEmail from \"../utilities/isEmail\";\r\nimport isURL from \"../utilities/isURL\";\r\nimport isZIP from \"../utilities/isZIP\";\r\nimport validateCheckbox from \"./validateCheckbox\";\r\nimport validateRadio from \"./validateRadio\";\r\n\r\n/**\r\n * Validate an input field.\r\n * @param {HTMLInputElement} inputField - The input field to validate.\r\n * @param {Object} customErrorMessages - Custom error messages for form validation.\r\n * @returns {boolean} Returns true if the input field is valid, otherwise false.\r\n */\r\nconst validateInput = (\r\n    inputField: HTMLInputElement, \r\n    options: any,\r\n    callback?: any\r\n): boolean | string | ErrorMessageInterface => {\r\n\r\n    let individualResponseMessage: ErrorMessageInterface = { message: \"\", type: 'error', data: null, code : 400 };\r\n\r\n\r\n    // Check if running in a browser environment\r\n    if (typeof window === 'undefined') {\r\n        // let logLevel: \r\n        console.error(\"To access this function, you will need to execute it in a browser like Google Chrome, Safari, Firefox, Microsoft Edge, etc.\");\r\n        ExceptionHandler(\"To access this function, you will need to execute it in a browser like Google Chrome, Safari, Firefox, Microsoft Edge, etc.\", 'big')\r\n        return false;\r\n    }\r\n    \r\n    // Check if the input field exists\r\n    if (!inputField) {\r\n        console.error(\"The input field you are trying to validate does not exist.\");\r\n        return false;\r\n    }\r\n\r\n\r\n    if ( checkVariableType(options) !== 'object' )\r\n    {\r\n        ExceptionHandler(\"options are not provided\");\r\n        individualResponseMessage.message = \"options are not provided\"\r\n        return individualResponseMessage;\r\n    }\r\n\r\n    // console.log(\"Input \", inputField);\r\n    // console.log(\"OPtions \", options.errorType);\r\n    // console.log(\"Form:\", options.form);\r\n    \r\n\r\n    \r\n    \r\n\r\n    const errorType: any = options.error_type || options.errorType || 'inline'; \r\n    const customErrorMessages: any = options.customErrorMessages || [];\r\n    const form: any = options.form ?? undefined;\r\n    const includeHTML = options.includeHTML === false ? false : true;\r\n\r\n\r\n    const inputType = inputField.getAttribute(\"type\") as string;\r\n    const inputValue = inputField.value.trim();\r\n    const isRequired = inputField.required || inputField.classList.contains('js-required');\r\n    let errorMessage: string | undefined = undefined;\r\n\r\n\r\n    if (! includeHTML)\r\n    {\r\n\r\n        // Check if the input field is required and its value is empty\r\n        if (isRequired && inputValue === '') {\r\n            errorMessage = customErrorMessages[inputType] ?? \"This field is required.\";\r\n        }\r\n        else if (isRequired && inputType === 'radio') {\r\n            options.ignoreError = true;\r\n            const validateRadioResponse = validateRadio(inputField, options);\r\n    \r\n            if ( validateRadioResponse === true )\r\n            {\r\n                errorMessage = 'validated'\r\n            }\r\n            else\r\n            {\r\n                errorMessage = customErrorMessages[inputType] ?? validateRadioResponse.message;\r\n            }\r\n    \r\n        }\r\n        else if (isRequired && inputType === 'checkbox' && !validateCheckbox(inputField, {form: form, customErrorMessages: customErrorMessages})) {\r\n            errorMessage = customErrorMessages[inputType] ?? 'You need to check this box';\r\n        }\r\n        else {\r\n            // Perform additional validation based on the input field type\r\n            switch (inputType) {\r\n                case 'email':\r\n                    if (inputValue !== '' && !isEmail(inputValue)) {\r\n                        errorMessage = customErrorMessages.email?.format || \"Invalid email format.\";\r\n                    }\r\n                    break;\r\n                case 'url':\r\n                    if (inputValue !== '' && !isURL(inputValue)) {\r\n                        errorMessage = customErrorMessages.url?.format || \"Invalid URL format.\";\r\n                    }\r\n                    break;\r\n                case 'zipcode':\r\n                    if (inputValue !== '' && !isZIP(inputValue)) {\r\n                        errorMessage = customErrorMessages.zipcode?.format || \"Invalid ZIP code format.\";\r\n                    }\r\n                    break;\r\n                case 'date':\r\n                    if (inputValue !== '' && !isDate(inputValue)) {\r\n                        errorMessage = customErrorMessages.date?.format || \"Invalid date format.\";\r\n                    }\r\n                    break;\r\n                case 'tel':\r\n                    if (inputValue !== '' && !containsOnlyIntegers(inputValue)) {\r\n                        errorMessage = customErrorMessages.tel?.format || customErrorMessages.phone?.format || \"Invalid phone number.\";\r\n                    }\r\n                    break;\r\n                case 'phone':\r\n                    if (inputValue !== '' && !containsOnlyIntegers(inputValue)) {\r\n                        errorMessage = customErrorMessages.tel?.format || customErrorMessages.phone?.format || \"Invalid date format.\";\r\n                    }\r\n                    break;\r\n                // case 'radio':\r\n                //     if (inputValue !== '' && !validateRadio(inputField, options)) {\r\n                //         errorMessage = customErrorMessages.radio?.format || \"Invalid radio button selection.\";\r\n                //     }\r\n                // case 'checkbox':\r\n                //     if (inputValue !== '' && !validateCheckbox(inputField)) {\r\n                //         errorMessage = customErrorMessages.checkbox?.format || \"Invalid checkbox selection.\";\r\n                //     }\r\n\r\n                default:\r\n                    // No additional validation for other input types\r\n                    break;\r\n            }\r\n        }\r\n\r\n            // Display the error message if validation fails\r\n            if (errorMessage) {\r\n                \r\n                individualResponseMessage.message = errorMessage;\r\n                individualResponseMessage.data = inputField\r\n\r\n                // if ( errorType === 'inline' )\r\n                // {\r\n                //     displayErrorInline(inputField, errorMessage)\r\n        \r\n                // }\r\n                // else\r\n                // {\r\n                //     focusInputElement(inputField);\r\n                //     displayErrorModal(errorMessage, inputField)\r\n                // }\r\n\r\n                ExceptionHandler(errorMessage);\r\n                return individualResponseMessage;\r\n            }\r\n\r\n            return true;\r\n\r\n    }\r\n\r\n    if ( ! form )\r\n    {\r\n\r\n        individualResponseMessage.message = \"The form you are trying to validate does not exist.\";\r\n        ExceptionHandler(\"The form you are trying to validate does not exist.\")\r\n        // failureReturnMessage.push(individualResponseMessage)\r\n        return individualResponseMessage;\r\n\r\n    }\r\n\r\n    \r\n\r\n    // Get the input field type, value, and required status\r\n    // const inputType = inputField.type;\r\n\r\n    // console.log(\"inputValue: \", inputValue);\r\n    \r\n    \r\n    // Check if the input field is required and its value is empty\r\n    if (isRequired && inputValue === '') {\r\n        errorMessage = customErrorMessages[inputType] ?? \"This field is required.\";\r\n    }\r\n    else if (isRequired && inputType === 'radio') {\r\n        options.ignoreError = true;\r\n        const validateRadioResponse = validateRadio(inputField, options);\r\n\r\n        if ( validateRadioResponse === true )\r\n        {\r\n            errorMessage = 'validated'\r\n        }\r\n        else\r\n        {\r\n            errorMessage = customErrorMessages[inputType] ?? validateRadioResponse.message;\r\n        }\r\n\r\n    }\r\n    else if (isRequired && inputType === 'checkbox' && !validateCheckbox(inputField, {form: form, customErrorMessages: customErrorMessages})) {\r\n        errorMessage = customErrorMessages[inputType] ?? 'You need to check this box';\r\n    }\r\n    else {\r\n        // Perform additional validation based on the input field type\r\n        switch (inputType) {\r\n            case 'email':\r\n                if (inputValue !== '' && !isEmail(inputValue)) {\r\n                    errorMessage = customErrorMessages.email?.format || \"Invalid email format.\";\r\n                }\r\n                break;\r\n            case 'url':\r\n                if (inputValue !== '' && !isURL(inputValue)) {\r\n                    errorMessage = customErrorMessages.url?.format || \"Invalid URL format.\";\r\n                }\r\n                break;\r\n            case 'zipcode':\r\n                if (inputValue !== '' && !isZIP(inputValue)) {\r\n                    errorMessage = customErrorMessages.zipcode?.format || \"Invalid ZIP code format.\";\r\n                }\r\n                break;\r\n            case 'date':\r\n                if (inputValue !== '' && !isDate(inputValue)) {\r\n                    errorMessage = customErrorMessages.date?.format || \"Invalid date format.\";\r\n                }\r\n                break;\r\n            case 'tel':\r\n                if (inputValue !== '' && !containsOnlyIntegers(inputValue)) {\r\n                    errorMessage = customErrorMessages.tel?.format || customErrorMessages.phone?.format || \"Invalid phone number.\";\r\n                }\r\n                break;\r\n            case 'phone':\r\n                if (inputValue !== '' && !containsOnlyIntegers(inputValue)) {\r\n                    errorMessage = customErrorMessages.tel?.format || customErrorMessages.phone?.format || \"Invalid date format.\";\r\n                }\r\n                break;\r\n            // case 'radio':\r\n            //     if (inputValue !== '' && !validateRadio(inputField, options)) {\r\n            //         errorMessage = customErrorMessages.radio?.format || \"Invalid radio button selection.\";\r\n            //     }\r\n            // case 'checkbox':\r\n            //     if (inputValue !== '' && !validateCheckbox(inputField)) {\r\n            //         errorMessage = customErrorMessages.checkbox?.format || \"Invalid checkbox selection.\";\r\n            //     }\r\n\r\n            // Add additional cases for other input types if needed\r\n            default:\r\n                // No additional validation for other input types\r\n                break;\r\n        }\r\n    }\r\n\r\n\r\n    // Display the error message if validation fails\r\n    if (errorMessage) {\r\n        \r\n\r\n        individualResponseMessage.message = errorMessage;\r\n        individualResponseMessage.data = inputField\r\n        \r\n        if ( errorType === 'inline' )\r\n        {\r\n            displayErrorInline(inputField, errorMessage)\r\n\r\n        }\r\n        else\r\n        {\r\n            focusInputElement(inputField);\r\n            displayErrorModal(errorMessage, inputField)\r\n        }\r\n\r\n        ExceptionHandler(errorMessage);\r\n        return individualResponseMessage;\r\n    }\r\n\r\n    individualResponseMessage.code = 200\r\n    individualResponseMessage.data = null\r\n    individualResponseMessage.message = \"success\"\r\n    individualResponseMessage.type = \"success\"\r\n\r\n    return true; // Input field is valid\r\n};\r\n\r\nexport default validateInput;\r\n","import { ExceptionHandler } from \"../errorHandling/ExceptionHandler\";\r\nimport ErrorMessageInterface from \"../interfaces/ErrorMessagesInterface\";\r\nimport { areAllElementsTrue } from \"../utilities\";\r\nimport validateInput from \"./validateInput\";\r\n\r\n/**\r\n * Validate all input fields within a form.\r\n * @param {HTMLFormElement | HTMLDivElement} form - The form element to validate.\r\n * @param {Object} customErrorMessages - Custom error messages for form validation.\r\n * @returns {boolean} Returns true if all input fields are valid, otherwise false.\r\n */\r\nconst validateAllInput = (form: HTMLFormElement | HTMLDivElement | string, options = {\r\n    customErrorMessages: [],\r\n    form\r\n}):  ErrorMessageInterface[] | boolean => {\r\n\r\n    const failureReturnMessage:ErrorMessageInterface[] = [];\r\n    let individualResponseMessage: ErrorMessageInterface = { message: \"\", code : 400 };\r\n\r\n\r\n    // Check if running in a browser environment\r\n    if (typeof window === 'undefined') {\r\n        \r\n        individualResponseMessage.message = \"To access this function, you will need to execute it in a browser like Google Chrome, Safari, Firefox, Microsoft Edge, etc.\"\r\n    \r\n        failureReturnMessage.push(individualResponseMessage)\r\n\r\n        return failureReturnMessage;\r\n    }\r\n\r\n    // Check if the form parameter is a string (ID) and convert it to a form element if necessary\r\n    if (typeof form === 'string') {\r\n        form = document.getElementById(form) as HTMLFormElement | HTMLDivElement;\r\n    }\r\n\r\n    // Check if the form element exists\r\n    if (!form) {\r\n        individualResponseMessage.message = \"The form you are trying to validate does not exist.\";\r\n        failureReturnMessage.push(individualResponseMessage)\r\n        ExceptionHandler(individualResponseMessage.message);\r\n        return failureReturnMessage;\r\n    }\r\n\r\n    const shouldContinue: boolean[] = [];\r\n    const allInputsInForm: NodeListOf<HTMLInputElement> = form.querySelectorAll('input');\r\n    \r\n    // If there are input fields in the form\r\n    if (allInputsInForm.length > 0) {\r\n\r\n        allInputsInForm.forEach((input: HTMLInputElement) => {\r\n\r\n            options.form = options.form || form\r\n\r\n            // Validate each input field using the validateInput function\r\n            const validateInputResponse = validateInput(input, options)\r\n            if (validateInputResponse === true) {\r\n                shouldContinue.push(true);\r\n            } else {\r\n                let individualResponseMessage: ErrorMessageInterface = { message: \"\", code : 400 , data: null};\r\n\r\n                shouldContinue.push(false);\r\n\r\n                // console.log(validateInputResponse);\r\n                \r\n\r\n                let proccessedResponse: string = validateInputResponse.message as string;\r\n\r\n                individualResponseMessage.message = proccessedResponse\r\n                individualResponseMessage.data = input\r\n\r\n                failureReturnMessage.push(individualResponseMessage)\r\n\r\n            }\r\n        });\r\n\r\n    } else {\r\n        // If there are no input fields in the form, consider it as valid\r\n        shouldContinue.push(true);\r\n    }\r\n\r\n    // Check if all validation results are the same (either all true or all false)\r\n    const checkIfAllElementsAreTrue = areAllElementsTrue(shouldContinue);\r\n\r\n    if ( checkIfAllElementsAreTrue )\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return failureReturnMessage;\r\n\r\n};\r\n\r\nexport default validateAllInput;\r\n","import { checkVariableType } from \"../utilities\";\r\nimport displayErrorInline from \"../errorHandling/displayErrorInline\";\r\nimport displayErrorModal from \"../errorHandling/displayErrorModal\";\r\nimport focusInputElement from \"../utilities/focusInputElement\";\r\nimport { ExceptionHandler } from \"../errorHandling/ExceptionHandler\";\r\nimport ErrorMessageInterface from \"../interfaces/ErrorMessagesInterface\";\r\n/**\r\n * Validates a select field.\r\n * @param {HTMLSelectElement} selectField - The select element to validate.\r\n * @param {object} customErrorMessage - Custom error message for select validation.\r\n * @param {HTMLElement} form - The form element associated with the select. Default is undefined.\r\n * @param {boolean} isErrorInline - Whether to display error inline or in a modal. Default is false.\r\n * @returns {boolean} - Returns true if validation succeeds, otherwise false.\r\n */\r\nconst validateSelect = (\r\n    selectField: HTMLSelectElement,\r\n    options: any,\r\n    callback?: any\r\n): boolean | ErrorMessageInterface => {\r\n\r\n    let individualResponseMessage: ErrorMessageInterface = { message: \"\", type: 'error', code : 400 };\r\n\r\n\r\n    // Check if running in a browser environment\r\n    if (typeof window === 'undefined') {\r\n        console.error(\"To access this function, you will need to execute it in a browser like Google Chrome, Safari, Firefox, Microsoft Edge, etc.\");\r\n        ExceptionHandler(\"To access this function, you will need to execute it in a browser like Google Chrome, Safari, Firefox, Microsoft Edge, etc.\", 'big')\r\n        return false;\r\n    }\r\n\r\n    // Check if the select field is valid and exists in the DOM\r\n    if (!selectField) {\r\n        console.error(\"The select element to validate is not found.\");\r\n        return false;\r\n    }\r\n\r\n    if ( checkVariableType(options) !== 'object' )\r\n    {\r\n        ExceptionHandler(\"options are not provided\");\r\n        return false;\r\n    }\r\n\r\n    const isErrorInline: string = options.error_type || options.errorType || 'inline';\r\n    const customErrorMessages: any = options.customErrorMessages || [];\r\n    const form: HTMLFormElement | HTMLDivElement | undefined = options.form || undefined;\r\n    const includeHTML = options.includeHTML === false ? false : true;\r\n\r\n    // Determine if the select field is required based on the 'required' attribute\r\n    const isRequired: boolean = selectField.hasAttribute('required') || selectField.classList.contains('js-required');\r\n\r\n    // Check if the select field has a value selected\r\n    const selectValue: string = selectField.value.trim();\r\n\r\n    \r\n    // Determine the error message for select validation\r\n    let errorMessage: string = customErrorMessages?.select || \"You have to select an option.\";\r\n\r\n    if ( ! includeHTML )\r\n    {\r\n\r\n        // Perform the validation for the select field\r\n        if (isRequired && !selectValue) {\r\n\r\n            ExceptionHandler(errorMessage)\r\n\r\n            individualResponseMessage.message = errorMessage;\r\n            individualResponseMessage.data = selectField\r\n\r\n            return individualResponseMessage; // Validation failed\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    if ( ! form )\r\n    {\r\n\r\n        individualResponseMessage.message = \"The form you are trying to validate does not exist.\";\r\n        ExceptionHandler(\"The form you are trying to validate does not exist.\")\r\n        return individualResponseMessage;\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    // Perform the validation for the select field\r\n    if (isRequired && !selectValue) {\r\n\r\n        ExceptionHandler(errorMessage)\r\n\r\n        individualResponseMessage.message = errorMessage;\r\n        individualResponseMessage.data = selectField\r\n\r\n        // If the select field is required and no value is selected, show the error message\r\n        if (isErrorInline) {\r\n            displayErrorInline(selectField, errorMessage, 3000);\r\n        } else {\r\n            focusInputElement(selectField, 3000);\r\n            displayErrorModal(errorMessage, form);\r\n        }\r\n        return individualResponseMessage; // Validation failed\r\n    }\r\n\r\n    individualResponseMessage.code = 200\r\n    individualResponseMessage.data = null\r\n    individualResponseMessage.message = \"success\"\r\n    individualResponseMessage.type = \"success\"\r\n\r\n    // Validation succeeded\r\n    return true;\r\n};\r\n\r\nexport default validateSelect;\r\n","import validateSelect from \"./validateSelect\";\r\nimport { areAllElementsTrue, checkVariableType } from \"../utilities\";\r\nimport { ExceptionHandler } from \"../errorHandling/ExceptionHandler\";\r\nimport ErrorMessageInterface from \"../interfaces/ErrorMessagesInterface\";\r\n\r\n/**\r\n * Validate all select fields within a form.\r\n * @param {HTMLFormElement | HTMLDivElement} form - The form element to validate.\r\n * @param {Object} customErrorMessage - Custom error messages for form validation.\r\n * @returns {boolean} Returns true if all select fields are valid or not required, otherwise false.\r\n */\r\nconst validateAllSelect = (form: HTMLFormElement | HTMLDivElement | string, options: any): boolean | ErrorMessageInterface | ErrorMessageInterface[] => {\r\n\r\n    const failureReturnMessage:ErrorMessageInterface[] = [];\r\n    let individualResponseMessage: ErrorMessageInterface = { message: \"\", code : 400 };\r\n\r\n\r\n    // Check if running in a browser environment\r\n    if (typeof window === 'undefined') {\r\n        console.error(\"To access this function, you will need to execute it in a browser like Google Chrome, Safari, Firefox, Microsoft Edge, etc.\");\r\n        return false;\r\n    }\r\n\r\n    // Check if the form parameter is a string (ID) and convert it to a form element if necessary\r\n    if (typeof form === 'string') {\r\n        form = document.getElementById(form) as HTMLFormElement | HTMLDivElement;\r\n    }\r\n\r\n    // Check if the form element exists\r\n    if (!form) {\r\n        individualResponseMessage.message = \"The form you are trying to validate does not exist.\";\r\n        failureReturnMessage.push(individualResponseMessage)\r\n        ExceptionHandler(individualResponseMessage.message);\r\n        return failureReturnMessage;\r\n    }\r\n\r\n    if ( checkVariableType(options) !== 'object' )\r\n    {\r\n        ExceptionHandler(\"options are not provided\");\r\n        individualResponseMessage.message = \"options are not provided\"\r\n        return individualResponseMessage;\r\n    }\r\n\r\n    const shouldContinue: boolean[] = [];\r\n    const allSelectsInForm: NodeListOf<HTMLSelectElement> = form.querySelectorAll('select');\r\n\r\n    // If there are select fields in the form\r\n    if (allSelectsInForm.length > 0) {\r\n        // Iterate through all select fields in the form\r\n        allSelectsInForm.forEach((select: HTMLSelectElement) => {\r\n\r\n\r\n            options.customErrorMessages = options.customErrorMessages ?? [],\r\n            options.form = options.form ?? form\r\n\r\n            const validateSelectResponse = validateSelect(select, options);\r\n\r\n            if (validateSelectResponse === true) {\r\n                shouldContinue.push(true); // Validation succeeded for this select field\r\n            } else {\r\n                let individualResponseMessage: ErrorMessageInterface = { message: \"\", code : 400 };\r\n\r\n                shouldContinue.push(false); // Validation failed for this select field\r\n                let proccessedResponse: string = validateSelectResponse as string;\r\n\r\n                individualResponseMessage.message = proccessedResponse\r\n                individualResponseMessage.data = select\r\n\r\n                failureReturnMessage.push(individualResponseMessage)\r\n\r\n            }\r\n        });\r\n    } else {\r\n        shouldContinue.push(true); // No select fields found in the form\r\n    }\r\n\r\n    // Check if all validation results are the same (either all true or all false)\r\n    const checkIfAllElementsAreTrue = areAllElementsTrue(shouldContinue);\r\n\r\n    if ( checkIfAllElementsAreTrue )\r\n    {\r\n        return true;\r\n    }\r\n    \r\n    return failureReturnMessage;    \r\n};\r\n\r\nexport default validateAllSelect;\r\n","import { checkVariableType } from \"../utilities\";\r\nimport displayErrorInline from \"../errorHandling/displayErrorInline\";\r\nimport displayErrorModal from \"../errorHandling/displayErrorModal\";\r\nimport focusInputElement from \"../utilities/focusInputElement\";\r\nimport { ExceptionHandler } from \"../errorHandling/ExceptionHandler\";\r\nimport ErrorMessageInterface from \"../interfaces/ErrorMessagesInterface\";\r\n\r\n/**\r\n * Validates a textarea field.\r\n * @param {HTMLTextAreaElement} textareaField - The textarea element to validate.\r\n * @param {object} customErrorMessage - Custom error message for textarea validation.\r\n * @param {boolean} isErrorInline - Whether to display error inline or in a modal. Default is false.\r\n * @param {HTMLElement} form - The form element associated with the textarea. Default is undefined.\r\n * @returns {boolean} - Returns true if validation succeeds, otherwise false.\r\n */\r\nconst validateTextarea = (\r\n    textareaField: HTMLTextAreaElement,\r\n    options: any,\r\n    callback?: any\r\n): boolean | string | ErrorMessageInterface => {\r\n\r\n    let individualResponseMessage: ErrorMessageInterface = { message: \"\", type: 'error', code : 400 };\r\n\r\n    // Check if running in a browser environment\r\n    if (typeof window === 'undefined') {\r\n        console.error(\"To access this function, it must be executed in a browser environment.\");\r\n        ExceptionHandler(\"To access this function, you will need to execute it in a browser like Google Chrome, Safari, Firefox, Microsoft Edge, etc.\", 'big')\r\n        return false;\r\n    }\r\n\r\n\r\n    // Check if the textarea element is valid and exists in the DOM\r\n    if ( ! textareaField )\r\n    {\r\n\r\n        individualResponseMessage.message = \"The form you are trying to validate does not exist.\";\r\n        ExceptionHandler(\"The form you are trying to validate does not exist.\")\r\n        // failureReturnMessage.push(individualResponseMessage)\r\n        return individualResponseMessage;\r\n\r\n    }\r\n\r\n    if ( checkVariableType(options) !== 'object' )\r\n    {\r\n        ExceptionHandler(\"options are not provided\");\r\n\r\n        individualResponseMessage.message = \"options are not provided\";\r\n\r\n        return individualResponseMessage;\r\n    }\r\n\r\n    const isErrorInline: string = options.error_type || options.errorType || 'inline';\r\n    const customErrorMessages: any = options.customErrorMessages || [];\r\n    const form: HTMLFormElement | HTMLDivElement | undefined = options.form || undefined;\r\n    const includeHTML = options.includeHTML === false ? false : true;\r\n\r\n    // Determine if the textarea is required based on the 'required' attribute\r\n    const isRequired: boolean = textareaField.hasAttribute('required') || textareaField.classList.contains('js-required');\r\n\r\n    // Check if the textarea value is empty\r\n    const textareaValue: string = textareaField.value.trim();\r\n\r\n    // Determine the error message for textarea validation\r\n    let errorMessage: string = customErrorMessages?.textarea || \"Textarea cannot be left empty.\";\r\n\r\n    if ( ! includeHTML )\r\n    {\r\n\r\n        // Perform the validation for the select field\r\n        if (isRequired && ! textareaValue) {\r\n\r\n            ExceptionHandler(errorMessage)\r\n\r\n            individualResponseMessage.message = errorMessage;\r\n            individualResponseMessage.data = textareaField\r\n\r\n            return individualResponseMessage; // Validation failed\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    if ( ! form )\r\n    {\r\n\r\n        individualResponseMessage.message = \"The form you are trying to validate does not exist.\";\r\n        ExceptionHandler(\"The form you are trying to validate does not exist.\")\r\n        // failureReturnMessage.push(individualResponseMessage)\r\n        return individualResponseMessage;\r\n\r\n    }\r\n\r\n    // Perform the validation for the textarea\r\n    if (isRequired && ! textareaValue) {\r\n\r\n        ExceptionHandler(errorMessage)\r\n\r\n        individualResponseMessage.message = errorMessage;\r\n        individualResponseMessage.data = textareaField\r\n\r\n        // If the textarea is required and has no value, show the error message\r\n        if (isErrorInline === 'inline') {\r\n            displayErrorInline(textareaField, errorMessage, 3000);\r\n        } else {\r\n            focusInputElement(textareaField, 3000);\r\n            displayErrorModal(errorMessage, form);\r\n        }\r\n\r\n\r\n        return individualResponseMessage; // Validation failed\r\n    }\r\n\r\n    individualResponseMessage.code = 200\r\n    individualResponseMessage.data = null\r\n    individualResponseMessage.message = \"success\"\r\n    individualResponseMessage.type = \"success\"\r\n\r\n    // Validation succeeded\r\n    return true;\r\n};\r\n\r\nexport default validateTextarea;\r\n","import validateTextarea from \"./validateTextarea\";\r\nimport { areAllElementsTrue, checkVariableType } from \"../utilities\";\r\nimport { ExceptionHandler } from \"../errorHandling/ExceptionHandler\";\r\nimport ErrorMessageInterface from \"../interfaces/ErrorMessagesInterface\";\r\n\r\n/**\r\n * Validate all textarea fields within a form.\r\n * @param {HTMLFormElement | HTMLDivElement} form - The form element to validate.\r\n * @param {Object} customErrorMessage - Custom error messages for form validation.\r\n * @returns {boolean} Returns true if all textarea fields are valid or not required, otherwise false.\r\n */\r\nconst validateAllTextarea = (form: HTMLFormElement | HTMLDivElement | string, options: any, callback?: any): ErrorMessageInterface[] | ErrorMessageInterface | boolean => {\r\n    const failureReturnMessage:ErrorMessageInterface[] = [];\r\n    let individualResponseMessage: ErrorMessageInterface = { message: \"\", code : 400 };\r\n\r\n    // Check if running in a browser environment\r\n    if (typeof window === 'undefined') {\r\n        individualResponseMessage.message = \"To access this function, you will need to execute it in a browser like Google Chrome, Safari, Firefox, Microsoft Edge, etc.\"\r\n    \r\n        failureReturnMessage.push(individualResponseMessage)\r\n\r\n        return failureReturnMessage;\r\n    }\r\n\r\n    // Check if the form parameter is a string (ID) and convert it to a form element if necessary\r\n    if (typeof form === 'string') {\r\n        form = document.getElementById(form) as HTMLFormElement | HTMLDivElement;\r\n    }\r\n\r\n    // Check if the form element exists\r\n    if (!form) {\r\n        individualResponseMessage.message = \"The form you are trying to validate does not exist.\";\r\n        failureReturnMessage.push(individualResponseMessage)\r\n        ExceptionHandler(individualResponseMessage.message);\r\n        return failureReturnMessage;\r\n    }\r\n\r\n    if ( checkVariableType(options) !== 'object' )\r\n    {\r\n        ExceptionHandler(\"options are not provided\");\r\n        individualResponseMessage.message = \"options are not provided\"\r\n        return individualResponseMessage;\r\n    }\r\n\r\n    const shouldContinue: boolean[] = [];\r\n    const allTextareasInForm: NodeListOf<HTMLTextAreaElement> = form.querySelectorAll('textarea');\r\n\r\n    // If there are textarea fields in the form\r\n    if (allTextareasInForm.length > 0) {\r\n\r\n        // Iterate through all textarea fields in the form\r\n        allTextareasInForm.forEach((textarea: HTMLTextAreaElement, index: number) => {\r\n\r\n            let individualResponseMessage: ErrorMessageInterface = { message: \"\", code : 400 };\r\n\r\n            options.customErrorMessages = options.customErrorMessages ?? [] \r\n            options.errorType = options.errorType ??  'inline' \r\n            options.form = options.form ?? form\r\n\r\n            // Call the validateTextarea function for each textarea field\r\n            const validateAllTextareaResponse = validateTextarea(textarea,options);\r\n            if (validateAllTextareaResponse === true) {\r\n\r\n                shouldContinue.push(true); // Validation succeeded for this textarea field\r\n                \r\n            } else {\r\n\r\n                // console.log(validateAllTextareaResponse);\r\n                let individualResponseMessage: ErrorMessageInterface = { message: \"\", code : 400 };\r\n                \r\n\r\n                shouldContinue.push(false); // Validation failed for this textarea field\r\n\r\n                let proccessedResponse: string = validateAllTextareaResponse as string;\r\n\r\n                individualResponseMessage.message = proccessedResponse\r\n                individualResponseMessage.data = textarea\r\n\r\n                failureReturnMessage.push(individualResponseMessage)\r\n\r\n            }\r\n\r\n        });\r\n    } else {\r\n        shouldContinue.push(true); // No textarea fields found in the form\r\n    }\r\n\r\n    // Check if all validation results are the same (either all true or all false)\r\n    const checkIfAllElementsAreTrue = areAllElementsTrue(shouldContinue);\r\n\r\n    if ( checkIfAllElementsAreTrue )\r\n    {\r\n        return true;\r\n    }\r\n\r\n    // console.log(\"Error87451365: \",failureReturnMessage);\r\n    \r\n    return failureReturnMessage;\r\n};\r\n\r\nexport default validateAllTextarea;\r\n","// import { ExceptionHandler } from \"../errorHandling/ExceptionHandler\";\r\n// import ErrorMessageInterface from \"../interfaces/ErrorMessagesInterface\";\r\n// import { areAllElementsTrue, checkVariableType } from \"../utilities\";\r\n// import validateAllInput from \"./validateAllnput\";\r\n// import validateAllSelect from \"./validateAllSelect\";\r\n// import validateAllTextarea from \"./validateAllTextarea\";\r\n\r\n// /**\r\n//  * Validate Form Inputs, Textareas, and Selects\r\n//  * @param {HTMLFormElement} form - The form element to validate.\r\n//  * @param {Object} customErrorMessages - Custom error messages for form validation (optional).\r\n//  * @param {boolean} isErrorInline - Whether to display error messages inline or in a modal (optional).\r\n//  * @returns {boolean} Returns true if form validation passes, otherwise false.\r\n//  */\r\n// const validateForm = (form: HTMLFormElement | HTMLDivElement | null, options?: any, isErrorInline?: boolean): boolean | ErrorMessageInterface | ErrorMessageInterface[] => {\r\n\r\n//     // Initialize errMsg with default values\r\n//     let errMsg: ErrorMessageInterface = { message: \"\", data: null, code : 400 };\r\n//     let errMsgArray: ErrorMessageInterface[] = [];\r\n\r\n//     // Check if the form exists; if not, log an error to the console and return false\r\n//     if (!form) {\r\n//         ExceptionHandler(\"Form element not found.\");\r\n\r\n//         errMsg.message = \"Form element not found.\";\r\n\r\n//         return errMsg;\r\n//     }\r\n\r\n\r\n//     // if ( checkVariableType(options) !== 'object' )\r\n//     // {\r\n//     //     ExceptionHandler(\"options are not provided\");\r\n//     //     errMsg.message = \"options are not provided\"\r\n//     //     errMsgArray.push(errMsg)\r\n//     //     return errMsgArray;\r\n//     // }\r\n\r\n//     // Initialize an array to track whether each validation check passes (true) or fails (false)\r\n//     const shouldContinue: boolean[] = [];\r\n\r\n//     // console.log(\"kytfdkftfln  \", options);\r\n    \r\n\r\n\r\n//     const isValidateAllInputs = validateAllInput(form, options);\r\n//     const isValidateAllTextareas = validateAllTextarea(form, options);\r\n//     const isValidateAllSelects = validateAllSelect(form, options);\r\n\r\n//     if (isValidateAllInputs === true) {\r\n//         shouldContinue.push(true);\r\n//     } else {\r\n\r\n//         let msg:ErrorMessageInterface = {code: 400, message: \"\"};\r\n//         let resMsg:ErrorMessageInterface[] = isValidateAllInputs as any;\r\n        \r\n//         msg.message = \"Inputs Validation Failed\";\r\n//         msg.data = resMsg\r\n\r\n//         errMsgArray.push(msg)\r\n\r\n//         // console.log(\"I AM AN ERROR: \", msg);\r\n//         errMsgArray['inputs'] = msg\r\n    \r\n//         shouldContinue.push(false);\r\n//     }\r\n\r\n//     if (isValidateAllTextareas === true) {\r\n//         shouldContinue.push(true);\r\n//     } else {\r\n//         shouldContinue.push(false);\r\n//         let msg:ErrorMessageInterface = {code: 400, message: \"\"};\r\n//         let resMsg:ErrorMessageInterface[] = isValidateAllTextareas as any;\r\n        \r\n//         msg.message = \"Textarea Validation Failed\";\r\n//         msg.data = resMsg\r\n\r\n//         errMsgArray.push(msg)\r\n//         errMsgArray['textareas'] = msg\r\n\r\n//     }\r\n\r\n//     if (isValidateAllSelects === true) {\r\n//         shouldContinue.push(true);\r\n//     } else {\r\n//         shouldContinue.push(false);\r\n//         let msg:ErrorMessageInterface = {code: 400, message: \"\"};\r\n//         let resMsg:ErrorMessageInterface[] = isValidateAllSelects as any;\r\n        \r\n//         msg.message = \"Selects Validation Failed\";\r\n//         msg.data = resMsg\r\n\r\n//         errMsgArray.push(msg)\r\n\r\n//         errMsgArray['selects'] = msg\r\n//     }\r\n\r\n    \r\n\r\n//     // Check if all elements in the shouldContinue array are equal to true\r\n//     const checkIfAllElementsAreTrue = areAllElementsTrue(shouldContinue);\r\n\r\n//     if ( checkIfAllElementsAreTrue )\r\n//     {\r\n//         return true;\r\n//     }\r\n\r\n//     const mainResponse:ErrorMessageInterface = {message: \"Form Validation Error\", data: errMsgArray};\r\n\r\n\r\n\r\n//     // console.log(\"MAIN RESPONSE: \", mainResponse);\r\n\r\n//     return mainResponse;\r\n\r\n// };\r\n\r\n// export default validateForm;\r\n\r\n\r\n\r\nimport { ExceptionHandler } from \"../errorHandling/ExceptionHandler\";\r\nimport ErrorMessageInterface from \"../interfaces/ErrorMessagesInterface\";\r\nimport { areAllElementsTrue, checkVariableType } from \"../utilities\";\r\nimport validateAllInput from \"./validateAllnput\";\r\nimport validateAllSelect from \"./validateAllSelect\";\r\nimport validateAllTextarea from \"./validateAllTextarea\";\r\n\r\nconst validateForm = (\r\n    form: HTMLFormElement | HTMLDivElement | null,\r\n    options?: any,\r\n    isErrorInline?: boolean\r\n): boolean | ErrorMessageInterface | { [key: string]: ErrorMessageInterface } => {\r\n\r\n    let errMsg: ErrorMessageInterface = { message: \"\", data: null, code: 400 };\r\n    let errMsgArray: { [key: string]: ErrorMessageInterface } = {};\r\n\r\n    if (!form) {\r\n        ExceptionHandler(\"Form element not found.\");\r\n        errMsg.message = \"Form element not found.\";\r\n        return errMsg;\r\n    }\r\n\r\n    const shouldContinue: boolean[] = [];\r\n\r\n    const isValidateAllInputs = validateAllInput(form, options);\r\n    const isValidateAllTextareas = validateAllTextarea(form, options);\r\n    const isValidateAllSelects = validateAllSelect(form, options);\r\n\r\n    if (isValidateAllInputs === true) {\r\n        shouldContinue.push(true);\r\n    } else {\r\n        let msg: ErrorMessageInterface = { code: 400, message: \"\" };\r\n        let resMsg: ErrorMessageInterface[] = isValidateAllInputs as any;\r\n\r\n        msg.message = \"Inputs Validation Failed\";\r\n        msg.data = resMsg;\r\n\r\n        errMsgArray['inputs'] = msg;\r\n        shouldContinue.push(false);\r\n    }\r\n\r\n    if (isValidateAllTextareas === true) {\r\n        shouldContinue.push(true);\r\n    } else {\r\n        shouldContinue.push(false);\r\n        let msg: ErrorMessageInterface = { code: 400, message: \"\" };\r\n        let resMsg: ErrorMessageInterface[] = isValidateAllTextareas as any;\r\n\r\n        msg.message = \"Textarea Validation Failed\";\r\n        msg.data = resMsg;\r\n\r\n        errMsgArray['textareas'] = msg;\r\n    }\r\n\r\n    if (isValidateAllSelects === true) {\r\n        shouldContinue.push(true);\r\n    } else {\r\n        shouldContinue.push(false);\r\n        let msg: ErrorMessageInterface = { code: 400, message: \"\" };\r\n        let resMsg: ErrorMessageInterface[] = isValidateAllSelects as any;\r\n\r\n        msg.message = \"Selects Validation Failed\";\r\n        msg.data = resMsg;\r\n\r\n        errMsgArray['selects'] = msg;\r\n    }\r\n\r\n    const checkIfAllElementsAreTrue = areAllElementsTrue(shouldContinue);\r\n\r\n    if (checkIfAllElementsAreTrue) {\r\n        return true;\r\n    }\r\n\r\n    const mainResponse: ErrorMessageInterface = {\r\n        message: \"Form Validation Error\",\r\n        data: errMsgArray\r\n    };\r\n\r\n    return mainResponse;\r\n};\r\n\r\nexport default validateForm;\r\n","import { ExceptionHandler } from \"../errorHandling/ExceptionHandler\";\r\nimport ErrorMessageInterface from \"../interfaces/ErrorMessagesInterface\";\r\nimport { areAllElementsTrue, checkVariableType } from \"../utilities\";\r\nimport validateCheckbox from \"./validateCheckbox\";\r\n\r\n/**\r\n * Validates all checkbox inputs within a form.\r\n * @param {HTMLFormElement} form - The form element containing the checkbox inputs.\r\n * @param {object} customErrorMessages - Custom error messages for checkbox validation.\r\n * @returns {boolean} - Returns true if all checkbox inputs are valid or not required, otherwise false.\r\n */\r\nconst validateAllCheckbox = (form: HTMLFormElement | HTMLDivElement, options: any): boolean | ErrorMessageInterface | ErrorMessageInterface[]  => {\r\n\r\n    const failureReturnMessage:ErrorMessageInterface[] = [];\r\n    let individualResponseMessage: ErrorMessageInterface = { message: \"\", code : 400 };\r\n\r\n    // Check if running in a browser environment\r\n    if (typeof window === 'undefined') {\r\n        console.error(\"To access this function, you will need to execute it in a browser like Google Chrome, Safari, Firefox, Microsoft Edge, etc.\");\r\n        ExceptionHandler(\"To access this function, you will need to execute it in a browser like Google Chrome, Safari, Firefox, Microsoft Edge, etc.\", 'big')\r\n        return false;\r\n    }\r\n\r\n\r\n    // Check if the form element exists\r\n    if (!form) {\r\n        individualResponseMessage.message = \"The form you are trying to validate does not exist. 5555 0000\";\r\n        individualResponseMessage.data = form;\r\n        failureReturnMessage.push(individualResponseMessage)\r\n        ExceptionHandler(individualResponseMessage.message);\r\n        return failureReturnMessage;\r\n    }\r\n\r\n    if ( checkVariableType(options) !== 'object' )\r\n    {\r\n        ExceptionHandler(\"options are not provided\");\r\n        individualResponseMessage.message = \"options are not provided\"\r\n        return individualResponseMessage;\r\n    }\r\n\r\n    // Array to track the validation results for each checkbox\r\n    const shouldContinue: boolean[] = [];\r\n    \r\n    // Get all checkbox inputs within the form\r\n    const allCheckboxesInForm: NodeListOf<HTMLInputElement> = form.querySelectorAll('input[type=\"checkbox\"]');\r\n\r\n    if (allCheckboxesInForm.length > 0) {\r\n        // Iterate over each checkbox input\r\n        allCheckboxesInForm.forEach((checkbox: HTMLInputElement) => {\r\n\r\n            options.customErrorMessages = options.customErrorMessages ?? [],\r\n            options.form = options.form ?? form\r\n\r\n            const validateInputResponse = validateCheckbox(checkbox, options);\r\n\r\n            // Validate each checkbox input\r\n            if (validateInputResponse === true) {\r\n                shouldContinue.push(true); // Checkbox is valid or not required\r\n            } else {\r\n                shouldContinue.push(false); // Checkbox is required and not \r\n                let individualResponseMessage: ErrorMessageInterface = { message: \"\", code : 400 };\r\n\r\n                shouldContinue.push(false); // Validation failed for this select field\r\n                let proccessedResponse: string = validateInputResponse as string;\r\n\r\n                individualResponseMessage.message = proccessedResponse\r\n                individualResponseMessage.data = checkbox\r\n\r\n                failureReturnMessage.push(individualResponseMessage)\r\n            }\r\n\r\n        });\r\n    } else {\r\n        shouldContinue.push(true); // No checkboxes found, mark validation as successful\r\n    }\r\n\r\n    // Check if all validation results are the same (either all true or all false)\r\n    const checkIfAllElementsAreTrue = areAllElementsTrue(shouldContinue);\r\n\r\n    if ( checkIfAllElementsAreTrue )\r\n    {\r\n        return true;\r\n    }\r\n\r\n    // console.log(failureReturnMessage);\r\n\r\n    return failureReturnMessage;    \r\n\r\n};\r\n\r\nexport default validateAllCheckbox;\r\n","import { ExceptionHandler } from \"../errorHandling/ExceptionHandler\";\r\nimport ErrorMessageInterface from \"../interfaces/ErrorMessagesInterface\";\r\nimport { areAllElementsTrue, checkVariableType } from \"../utilities\";\r\nimport validateRadio from \"./validateRadio\";\r\n\r\n/**\r\n * Validates all radio inputs within a form.\r\n * @param {HTMLElement} form - The form element containing radio inputs to be validated.\r\n * @param {object} customErrorMessage - Custom error message for radio validation.\r\n * @returns {boolean} - Returns true if all radio inputs are valid, otherwise false.\r\n */\r\nconst validateAllRadio = (form: HTMLFormElement | HTMLDivElement | string, options: any): ErrorMessageInterface[] | ErrorMessageInterface | boolean => {\r\n\r\n    const failureReturnMessage:ErrorMessageInterface[] = [];\r\n    let individualResponseMessage: ErrorMessageInterface = { message: \"\", code : 400 };\r\n\r\n    // Check if running in a browser environment\r\n    if (typeof window === 'undefined') {\r\n        console.error(\"To access this function, it must be executed in a browser environment.\");\r\n        individualResponseMessage.message = \"To access this function, you will need to execute it in a browser like Google Chrome, Safari, Firefox, Microsoft Edge, etc.\"\r\n    \r\n        failureReturnMessage.push(individualResponseMessage)\r\n\r\n        return failureReturnMessage;\r\n        // return false;\r\n    }\r\n\r\n    // Check if the form parameter is a string (ID) and convert it to a form element if necessary\r\n    if (typeof form === 'string') {\r\n        form = document.getElementById(form) as HTMLFormElement | HTMLDivElement;\r\n    }\r\n\r\n    // Check if the form element exists\r\n    if (!form) {\r\n        individualResponseMessage.message = \"The form you are trying to validate does not exist.\";\r\n        failureReturnMessage.push(individualResponseMessage)\r\n        return failureReturnMessage;\r\n    }\r\n\r\n    if ( checkVariableType(options) !== 'object' )\r\n    {\r\n        ExceptionHandler(\"options are not provided\");\r\n        individualResponseMessage.message = \"options are not provided\"\r\n        return individualResponseMessage;\r\n    }\r\n\r\n    // Get all radio inputs within the form\r\n    const allRadiosInForm: NodeListOf<HTMLInputElement> = form.querySelectorAll('input[type=\"radio\"]');\r\n    const shouldContinue: boolean[] = [];\r\n\r\n    // Iterate through each radio input and validate\r\n    allRadiosInForm.forEach((radio: HTMLInputElement) => {\r\n\r\n        let individualResponseMessage: ErrorMessageInterface = { message: \"\", code : 400 };\r\n\r\n        const validateRadioResponse = validateRadio(radio, options);\r\n\r\n        if ( validateRadioResponse === true ) {\r\n\r\n            shouldContinue.push(true);\r\n\r\n        } else {\r\n\r\n            shouldContinue.push(false);\r\n\r\n            let proccessedResponse: string = validateRadioResponse.message as string;\r\n\r\n            individualResponseMessage.message = proccessedResponse\r\n            individualResponseMessage.data = radio\r\n\r\n            failureReturnMessage.push(individualResponseMessage)\r\n\r\n        }\r\n\r\n    });\r\n\r\n     // Check if all validation results are the same (either all true or all false)\r\n     const checkIfAllElementsAreTrue = areAllElementsTrue(shouldContinue);\r\n\r\n     if ( checkIfAllElementsAreTrue )\r\n     {\r\n         return true;\r\n     }\r\n \r\n    //  console.log(failureReturnMessage);\r\n     \r\n     return failureReturnMessage;\r\n};\r\n\r\nexport default validateAllRadio;\r\n","/**\r\n * Check if a given password meets specific criteria.\r\n * @param {string} password - The password to be checked.\r\n * @param {number} [minLength=8] - The minimum length required for the password (default: 8).\r\n * @param {number} [maxLength=20] - The maximum length allowed for the password (default: 20).\r\n * @param {boolean} [includeSymbolsCheck=false] - Flag to determine if symbols check is required (default: false).\r\n * @param {RegExp | string} [userSymbolRegex=''] - Custom regular expression or string representing symbols to check (default: '').\r\n * @returns {boolean | string} Returns true if the password meets the criteria; otherwise, returns an error message.\r\n */\r\nconst checkPassword = (\r\n    password: string,\r\n    includeSymbolsCheck: boolean = false,\r\n    minLength: number = 8,\r\n    maxLength: number = 20,\r\n    userSymbolRegex: RegExp | string = ''\r\n): boolean | string => {\r\n    // Regular expressions for checking uppercase, lowercase, and numeric characters.\r\n    const uppercaseRegex = /[A-Z]/;\r\n    const lowercaseRegex = /[a-z]/;\r\n    const numbersRegex = /[0-9]/;\r\n\r\n    // Check the length of the password.\r\n    if (password.length < minLength || password.length > maxLength) {\r\n        return `Make sure the length of your password ranges from ${minLength} - ${maxLength} characters`;\r\n    }\r\n\r\n    // Check if the password contains at least one uppercase letter.\r\n    if (!uppercaseRegex.test(password)) {\r\n        return \"Your password needs to have at least 1 uppercase (A-Z)\";\r\n    }\r\n\r\n    // Check if the password contains at least one lowercase letter.\r\n    if (!lowercaseRegex.test(password)) {\r\n        return \"Your password needs to have at least one lowercase (a-z)\";\r\n    }\r\n\r\n    // Check if the password contains at least one numeric character.\r\n    if (!numbersRegex.test(password)) {\r\n        return \"Your password needs to have at least one number (0-9)\";\r\n    }\r\n\r\n    // If symbols check is required, perform the check.\r\n    if (includeSymbolsCheck) {\r\n        // Define the regular expression for symbols or use the custom one provided by the user.\r\n        const symbolRegex = typeof userSymbolRegex === 'string' ? new RegExp(userSymbolRegex) : userSymbolRegex;\r\n\r\n        // Check if the password contains at least one symbol.\r\n        if (!symbolRegex.test(password)) {\r\n            return \"Your password needs to have one symbol e.g (!@#$%^&*())\";\r\n        }\r\n    }\r\n\r\n    // If all checks pass, return true.\r\n    return true;\r\n}\r\n\r\nexport default checkPassword;\r\n","import * as bcrypt from 'bcryptjs';\r\n\r\n\r\n/**\r\n * Hashes a password using bcrypt.\r\n * @param {string} password - The password to be hashed.\r\n * @returns {Promise<string>} A promise that resolves to the hashed password.\r\n */\r\nconst hashPassword = async (password: string): Promise<string> => {\r\n    // Generate a unique salt for each password\r\n    const salt = await bcrypt.genSalt(10);\r\n\r\n    // Hash the password with the generated salt using bcrypt\r\n    const hashedPassword = await bcrypt.hash(password, salt);\r\n\r\n    return hashedPassword;\r\n};\r\n\r\nexport default hashPassword;\r\n","import { ExceptionHandler } from \"../errorHandling/ExceptionHandler\";\r\nimport hashPassword from \"./hashPassword\";\r\n\r\n/**\r\n * Generates a random password.\r\n * @param {number} [length] - The length of the generated password. If not provided, a random length between 8 and 18 characters will be used.\r\n * @param {boolean} [shouldHash=false] - A flag indicating whether the generated password should be hashed. Default is false.\r\n * @returns {Promise<string | [string, string]>} - A Promise that resolves to the generated password. If shouldHash is true, resolves to an array containing the plain password and the hashed password.\r\n */\r\nconst generatePassword = async (length: number = Math.floor(Math.random() * 11) + 8, shouldHash: boolean = false):  Promise<any> => {\r\n    // The minimum length of the generated password.\r\n    const minLength: number = 8;\r\n\r\n    // The maximum length of the generated password.\r\n    const maxLength: number = 18;\r\n\r\n    // A string containing all uppercase letters.\r\n    const uppercaseLetters: string = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n\r\n    // A string containing all lowercase letters.\r\n    const lowercaseLetters: string = \"abcdefghijklmnopqrstuvwxyz\";\r\n\r\n    // A string containing all digits (numbers).\r\n    const numbers: string = \"0123456789\";\r\n\r\n    // A string containing all symbols.\r\n    const symbols: string = \"!@#$%^&*()\";\r\n\r\n    // The generated password.\r\n    let password: string = \"\";\r\n\r\n    // Validate the length parameter\r\n    if (length < minLength || length > maxLength) {\r\n        ExceptionHandler(\"Password length must be between 8 and 18 characters.\", 'error_1');\r\n    }\r\n\r\n    // Add at least one uppercase letter to the password.\r\n    password += uppercaseLetters[Math.floor(Math.random() * uppercaseLetters.length)];\r\n\r\n    // Add at least one symbol to the password.\r\n    password += symbols[Math.floor(Math.random() * symbols.length)];\r\n\r\n    // Add at least one number to the password.\r\n    password += numbers[Math.floor(Math.random() * numbers.length)];\r\n\r\n    // The number of characters already added to the password.\r\n    let charactersAdded: number = 3;\r\n\r\n    // Add remaining characters based on the provided length.\r\n    while (charactersAdded < length) {\r\n        // Choose a random character type: 0 for uppercase letter, 1 for lowercase letter, 2 for symbol, 3 for number.\r\n        const randomCharType: number = Math.floor(Math.random() * 4);\r\n\r\n        if (randomCharType === 0) {\r\n            password += uppercaseLetters[Math.floor(Math.random() * uppercaseLetters.length)];\r\n        } else if (randomCharType === 1) {\r\n            password += lowercaseLetters[Math.floor(Math.random() * lowercaseLetters.length)];\r\n        } else if (randomCharType === 2) {\r\n            password += symbols[Math.floor(Math.random() * symbols.length)];\r\n        } else {\r\n            password += numbers[Math.floor(Math.random() * numbers.length)];\r\n        }\r\n\r\n        charactersAdded++;\r\n    }\r\n\r\n    // If shouldHash is true, hash the generated password\r\n    if (shouldHash) {\r\n        const hashedPassword = await hashPassword(password);\r\n        return {0:password, 1:hashedPassword, password:password, hashedPassword:hashedPassword};\r\n    }\r\n\r\n\r\n    // Return the generated password.\r\n    return password;\r\n};\r\n\r\nexport default generatePassword;\r\n","import * as bcrypt from 'bcryptjs';\r\n\r\n/**\r\n * Verify a password against a hashed password.\r\n * @param {string} stringPassword - The plain text password to verify.\r\n * @param {string} hashedPassword - The hashed password to compare against.\r\n * @param {boolean} [isHashed=false] - Indicates whether the provided password is already hashed. Default is false.\r\n * @returns {Promise<boolean>} Returns a promise that resolves to true if the passwords match, false otherwise.\r\n */\r\nconst verifyPassword = async (stringPassword: string, hashedPassword: string, isHashed: boolean = false): Promise<boolean> => {\r\n    try {\r\n        if (isHashed) {\r\n            // Use bcrypt.compare to compare hashed passwords.\r\n            const match = await bcrypt.compare(stringPassword, hashedPassword);\r\n            return match; // Return the result of the comparison.\r\n        } else {\r\n            // Compare plain text passwords directly.\r\n            return stringPassword === hashedPassword;\r\n        }\r\n    } catch (error) {\r\n        console.error(\"Error comparing passwords: \", error); // Log an error if bcrypt.compare encounters an issue.\r\n        return false; // Return false in case of an error.\r\n    }\r\n};\r\n\r\nexport default verifyPassword;\r\n","/**\r\n * Checks the type of a variable and returns a string representation of the type.\r\n * If the type cannot be determined, returns 'unknown'.\r\n *\r\n * @param {*} variable - The variable whose type needs to be checked.\r\n * @returns {string} A string representing the type of the variable, or 'unknown'.\r\n */\r\nconst checkVariableType = (variable: any): string => {\r\n    // Check if the variable is a string\r\n    if (typeof variable === 'string') {\r\n        return 'string';\r\n    }\r\n    // Check if the variable is a number\r\n    else if (typeof variable === 'number') {\r\n        return 'number';\r\n    }\r\n    // Check if the variable is a boolean\r\n    else if (typeof variable === 'boolean') {\r\n        return 'boolean';\r\n    }\r\n    // Check if the variable is undefined\r\n    else if (typeof variable === 'undefined') {\r\n        return 'undefined';\r\n    }\r\n    // Check if the variable is null\r\n    else if (variable === null) {\r\n        return 'null';\r\n    }\r\n    // Check if the variable is an HTMLElement (assumes that HTMLElement is defined in the environment)\r\n    else if (variable instanceof HTMLElement) {\r\n        return 'HTML Element';\r\n    }\r\n    // Check if the variable is an array\r\n    else if (typeof variable === 'object' && variable instanceof Array) {\r\n        return 'array';\r\n    }\r\n    // Check if the variable is an object\r\n    else if (typeof variable === 'object' && variable instanceof Object) {\r\n        return 'object';\r\n    }\r\n    // Check if the variable is a function\r\n    else if (typeof variable === 'function') {\r\n        return 'function';\r\n    }\r\n    // If none of the above conditions match, the data type is unknown\r\n    else {\r\n        return 'null';\r\n    }\r\n}\r\n\r\nexport default checkVariableType;","const isOnline = (): boolean => {\r\n    // Check if the code is running in a browser environment\r\n    if (typeof window === 'undefined') {\r\n        console.error(\r\n            \"You need to be in a browser environment like Google Chrome, Safari, Firefox, Microsoft Edge, etc. for this function to work.\"\r\n        );\r\n        return false;\r\n    }\r\n\r\n    // Check if the browser reports that it is online\r\n    if (navigator.onLine) {\r\n        return true;\r\n    }\r\n\r\n    // Return false if the browser is not online\r\n    return false;\r\n};\r\n\r\nexport default isOnline;","import { ExceptionHandler } from \"../errorHandling/ExceptionHandler\";\r\nimport ErrorMessageInterface from \"../interfaces/ErrorMessagesInterface\";\r\nimport checkVariableType from \"../utilities/checkVariableType\";\r\n\r\n/**\r\n * Changes the content of a button or input element to a specified message while providing loading feedback.\r\n * @param {string} message - The message to set as the content of the button or input element.\r\n * @param {string | HTMLElement | null} submitBtn - The button or input element to update.\r\n * @param {string | HTMLElement | null} form - The HTML form element or its ID.\r\n * @returns {boolean} Returns true if the operation is successful, false if the button is not found.\r\n */\r\nconst loading = (message: string, submitBtn: string | HTMLElement | null = null, form: string | HTMLElement | null = null): boolean | ErrorMessageInterface => {\r\n    let btn: HTMLElement | null = null; // Initialize btn to null\r\n    let individualResponseMessage: ErrorMessageInterface = { message: \"error\", type: 'error', code : 400 };\r\n\r\n\r\n    // Check the type of submitBtn and find the corresponding element\r\n    if (checkVariableType(submitBtn) === 'HTML Element') {\r\n        btn = submitBtn as HTMLElement;\r\n    } else if (typeof submitBtn === 'string') {\r\n        btn = document.getElementById(submitBtn);\r\n    } else if (submitBtn === null && form) {\r\n        // Attempt to find a suitable button element if submitBtn is null\r\n        const formElement = typeof form === 'string' ? document.getElementById(form) : form;\r\n        if (formElement instanceof HTMLFormElement || formElement instanceof HTMLDivElement) {\r\n            btn = formElement.querySelector('button[type=\"submit\"], input[type=\"submit\"], #jsSubmit, input[type=\"search\"], button');\r\n        }\r\n    } else {\r\n        // Handle the case where the button is not found\r\n        // console.error(\"The button element specified is not found.\");\r\n        individualResponseMessage.message = \"The button element specified is not found.\";\r\n        ExceptionHandler(individualResponseMessage.message)\r\n        return individualResponseMessage;\r\n    }\r\n\r\n    if (!btn) {\r\n        individualResponseMessage.message = \"The button element specified is not found.\";\r\n        ExceptionHandler(individualResponseMessage.message)\r\n        return individualResponseMessage;\r\n    }\r\n\r\n    // Update the content of the button with the provided message\r\n    if (btn) {\r\n        if (btn.tagName.toLowerCase() === 'input') {\r\n            (btn as HTMLInputElement).value = message;\r\n        } else {\r\n            btn.innerHTML = message;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    individualResponseMessage.message = \"The button element specified is not found.\";\r\n    ExceptionHandler(individualResponseMessage.message)\r\n    return individualResponseMessage;\r\n};\r\n\r\nexport default loading;\r\n","import getPageUrl from \"./getPageUrl\";\r\n\r\n/**\r\n * Redirects the user to a specified URL, either immediately or after a specified delay.\r\n *\r\n * If the code is running in a browser environment, it uses window.location.href for redirection.\r\n * In a non-browser environment (e.g., Node.js console), it logs a message indicating the redirection.\r\n *\r\n * @param {string} [url=getPageUrl()] - An optional URL to which the user should be redirected.\r\n *                                           Defaults to the current page's URL if not provided.\r\n * @param {number} [delay=0] - An optional parameter to delay redirection in seconds.\r\n */\r\nconst redirect = (url: string | null = null , delay: number = 0) => {\r\n\r\n\r\n    if ( ! url )\r\n    {\r\n        url = getPageUrl() as string;\r\n    }\r\n\r\n    // Check if the code is running in a browser environment\r\n    if (typeof window !== 'undefined') {\r\n        // Redirect in a browser environment after the specified delay\r\n        setTimeout(() => {\r\n            window.location.href = url;\r\n        }, delay * 1000); // Convert seconds to milliseconds\r\n    } else {\r\n        // Running in a non-browser environment (e.g., Node.js console)\r\n        console.log(`Redirecting to: ${url || 'current page'} (Delayed: ${delay} seconds)`);\r\n    }\r\n\r\n};\r\n\r\nexport default redirect;","const reset = (form: HTMLFormElement | HTMLDivElement | string | null = null): boolean => {\r\n    // Check if the code is running in a browser environment\r\n    if (typeof window === 'undefined') {\r\n        console.error(\r\n            \"You need to be in a browser environment like Google Chrome, Safari, Firefox, Microsoft Edge, etc. for this function to work.\"\r\n        );\r\n        return false;\r\n    }\r\n\r\n    // Get the target form element\r\n    let targetForm: HTMLElement | null = null;\r\n    if (typeof form === 'string') {\r\n        // If the form parameter is a string, assume it's an ID and try to find the element\r\n        targetForm = document.getElementById(form);\r\n        if (!targetForm) {\r\n            console.error(`Form with ID \"${form}\" not found.`);\r\n            return false;\r\n        }\r\n    } else if (form instanceof HTMLFormElement || form instanceof HTMLDivElement) {\r\n        // If the form parameter is a valid HTMLFormElement or HTMLDivElement, use it directly\r\n        targetForm = form;\r\n    } else if (form === null) {\r\n        // If no form parameter is provided, default to the document's body\r\n        targetForm = document.body;\r\n    } else {\r\n        console.error(\"Invalid form parameter.\");\r\n        return false;\r\n    }\r\n\r\n    // Select all form elements within the target form\r\n    const allFormElements = targetForm.querySelectorAll<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>('input, textarea, select');\r\n\r\n    // Reset the values of input fields, textareas, and selected index of select elements\r\n    allFormElements.forEach((element: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement) => {\r\n        if (element instanceof HTMLInputElement) {\r\n            if (element.type === 'radio' || element.type === 'checkbox') {\r\n                element.checked = false;\r\n            } else {\r\n                element.value = '';\r\n            }\r\n        } else if (element instanceof HTMLTextAreaElement) {\r\n            element.value = '';\r\n        } else if (element instanceof HTMLSelectElement) {\r\n            element.selectedIndex = 0;\r\n        }\r\n    });\r\n\r\n    return true;\r\n};\r\n\r\nexport default reset;\r\n","import { checkVariableType } from \".\";\r\nimport { ExceptionHandler } from \"../errorHandling/ExceptionHandler\";\r\n\r\n/**\r\n * Toggles the visibility of a password input and updates the corresponding visibility icon.\r\n * @param {HTMLElement} input - The password input element.\r\n * @param {Element} [showIcon=null] - Icon for showing the password.\r\n * @param {Element} [hideIcon=null] - Icon for hiding the password.\r\n * @returns {void}\r\n */\r\nconst togglePasswordVisibility = (input: HTMLInputElement, showIcon: string | HTMLElement | null = null, hideIcon: string | HTMLElement | null = null): boolean | any => {\r\n\r\n\r\n    let allTogglePasswordsButton : any | undefined = document.querySelectorAll('.nfsfu234_fv_togglePassword') || document.querySelectorAll('.js-togglePassword') || undefined;\r\n    \r\n    // if ( allTogglePasswordsButton.length < 1 )\r\n    // {\r\n\r\n    //     allTogglePasswordsButton = document.querySelectorAll('.js-togglePassword');\r\n\r\n    // }\r\n    \r\n    // if ( allTogglePasswordsButton.length < 1 )\r\n    // {\r\n\r\n    //     allTogglePasswordsButton = undefined;\r\n\r\n    // }\r\n\r\n\r\n    if ( ! allTogglePasswordsButton )\r\n    {\r\n        ExceptionHandler(\"No Toggle Password Button was found. Check your HTML Code\", 'error_1')\r\n        return false;\r\n    }\r\n\r\n    function updateIcon(inputType:string, iconContainer:HTMLElement) {\r\n\r\n        if (showIcon === null) {\r\n            // iconContainer.appendChild(showIcon.cloneNode(true));\r\n\r\n            // iconContainer.innerHTML = \"\"\r\n\r\n            showIcon = \"show\"\r\n\r\n        } \r\n        \r\n        if (hideIcon === null) {\r\n            // iconContainer.appendChild(hideIcon.cloneNode(true));\r\n\r\n            // iconContainer.innerHTML = \"\"\r\n\r\n            hideIcon = \"hide\"\r\n\r\n        }\r\n\r\n        // Append the appropriate icon.\r\n        if (inputType === 'password' && showIcon !== null) {\r\n            // iconContainer.appendChild(showIcon.cloneNode(true));\r\n\r\n            iconContainer.innerHTML = \"\"\r\n\r\n            if ( typeof showIcon === \"string\" )\r\n            {\r\n                iconContainer.innerHTML = showIcon\r\n            }\r\n            else if ( checkVariableType(showIcon) === \"HTML Element\" )\r\n            {\r\n                iconContainer.appendChild(showIcon)\r\n            }\r\n            else\r\n            {\r\n                iconContainer.innerHTML = showIcon\r\n            }\r\n\r\n        } else if (inputType === 'text' && hideIcon !== null) {\r\n            // iconContainer.appendChild(hideIcon.cloneNode(true));\r\n            iconContainer.innerHTML = \"\"\r\n\r\n            if ( typeof hideIcon === \"string\" )\r\n            {\r\n                iconContainer.innerHTML = hideIcon\r\n            }\r\n            else if ( checkVariableType(hideIcon) === \"HTML Element\" )\r\n            {\r\n                iconContainer.appendChild(hideIcon)\r\n            }\r\n            else\r\n            {\r\n                iconContainer.innerHTML = showIcon\r\n            }\r\n\r\n        }\r\n\r\n\r\n    }\r\n\r\n    allTogglePasswordsButton.forEach( (toggleBtn: HTMLElement) => {\r\n\r\n        let inputType = input.type;\r\n        const iconContainer: HTMLElement | null = input.nextElementSibling as HTMLElement;\r\n\r\n        updateIcon(inputType, iconContainer)\r\n\r\n        toggleBtn.addEventListener('click', ()=>{\r\n\r\n            // Toggle the input type between 'password' and 'text'.\r\n            input.type = input.type === 'password' ? 'text' : 'password';\r\n\r\n            // Update the visibility icon based on the current input type.\r\n            const inputType: string = input.type;\r\n            if (iconContainer) {\r\n                // Clear existing icon content.\r\n                // iconContainer.textContent = '';\r\n\r\n                updateIcon(inputType, iconContainer)\r\n\r\n            }\r\n\r\n        })\r\n\r\n    } )\r\n\r\n\r\n\r\n};\r\n\r\n\r\nexport default togglePasswordVisibility;","import { ExceptionHandler } from \"../errorHandling/ExceptionHandler\";\r\nimport togglePasswordVisibility from \"./togglePasswordVisibility\";\r\n\r\n/**\r\n * Toggles the visibility of password inputs and updates corresponding visibility icons.\r\n * @param {object} [icons={}] - Object containing icons for showing and hiding the password.\r\n * @param {Element} [icons.show=null] - Icon for showing the password.\r\n * @param {Element} [icons.hide=null] - Icon for hiding the password.\r\n * @param {string | HTMLElement} [uform=null] - The form element or its ID.\r\n * @param {boolean} [toggleAll=false] - Flag indicating whether to toggle all password inputs.\r\n * @returns {void}\r\n */\r\nconst togglePasswordVisibilityAll = (icons: { show?: string | HTMLElement | null, hide?: string | HTMLElement | null } = {}, uform: string | HTMLFormElement | HTMLDivElement | null = null, toggleAll: boolean = false): void => {\r\n    // Get the form element based on the provided ID or directly.\r\n    const form: HTMLElement | null = typeof uform === 'string' ? document.getElementById(uform) : uform;\r\n\r\n    if (!form) {\r\n        console.error('Form element not found.');\r\n        ExceptionHandler(\"Form Element not found\");\r\n        return;\r\n    }\r\n\r\n    // Get all password inputs within the specified form.\r\n    const allPasswordInputs: NodeListOf<HTMLInputElement> = form.querySelectorAll('input[type=\"password\"]');\r\n\r\n    // Get the icon elements for showing and hiding the password.\r\n    const showIcon: string | HTMLElement | null = icons.show || null;\r\n    const hideIcon: string | HTMLElement | null = icons.hide || null;\r\n\r\n    if (toggleAll) {\r\n        // Toggle visibility for all password inputs.\r\n        allPasswordInputs.forEach((input: HTMLInputElement) => {\r\n            togglePasswordVisibility(input, showIcon, hideIcon);\r\n        });\r\n    } else {\r\n        // Toggle visibility for the first password input.\r\n        if (allPasswordInputs.length > 0) {\r\n            togglePasswordVisibility(allPasswordInputs[0], showIcon, hideIcon);\r\n        }\r\n    }\r\n};\r\n\r\n\r\nexport default togglePasswordVisibilityAll;"]}